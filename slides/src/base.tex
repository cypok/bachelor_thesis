\documentclass[usenames,dvipsnames,pdftex,unicode]{beamer}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{algorithmic}
\usepackage{ulem}

\usepackage{tikz}
\usetikzlibrary{arrows,shapes}

\usetheme{Warsaw}
\usecolortheme{seahorse}

\setbeamercovered{transparent}

\title[Анализ указателей и синонимов]{
  Анализ указателей и синонимов для многопоточных программ
}
\author[Владимир Парфиненко]{
  Владимир Парфиненко\\
  {\small Научный руководитель: м.\,н.\,с.~ИСИ~СО~РАН, Павлов\,П.\,Е.}
}
\institute{
  Новосибирский Государственный Университет
}
\date{
  Новосибирск, 2011
}


% добавить номер фрейма в footline
\newcommand*\oldmacro{}
\let\oldmacro\insertshorttitle
\renewcommand*\insertshorttitle{
  \oldmacro\hfill
  \insertframenumber\,/\,\inserttotalframenumber
}

\newcommand{\algorithmictitle}[1]{\hspace{8mm}\textbf{#1}}

\newcommand{\remark}[1]{\textcolor{Green}{#1}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\todocite}{[\todo{cite}]}

\newcommand{\eng}[1]{{\English#1}}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Статический анализ}

  \begin{itemize}
    \item Оптимизирующие компиляторы\newline
        GCC, MSVC, ICC, Borland C++, MinGW, \ldots
    \item Инструменты статического анализа\newline
        SourceAnalyzer, ReSharper, Static Security Analyzer, \ldots
  \end{itemize}

\end{frame}

\begin{frame}{Вынесение инварианта из цикла}

  \begin{visibleenv}<2>
    \begin{center}
      \large А что если $x$ и $y$ указывают на один объект?
    \end{center}
  \end{visibleenv}

  \begin{columns}[t]
    \begin{column}{5cm}
      \begin{block}{Исходный код}
        \begin{algorithmic}
          \FOR{$i = 0 \textbf{ to } n$}
          \STATE $x.f = i$
          \STATE $a[i] = y.f$
          \ENDFOR
        \end{algorithmic}
      \end{block}
    \end{column}
    \begin{column}{5cm}
      \begin{block}{Преобразованный код}
        \begin{algorithmic}
          \STATE $temp = y.f$
          \FOR{$i = 0 \textbf{ to } n$}
          \STATE $x.f = i$
          \STATE $a[i] = temp$
          \ENDFOR
        \end{algorithmic}
      \end{block}
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}{Оптимизаторы и анализаторы}

  \tikzstyle{optimizer} = [rectangle, draw, thin, fill=blue!10,%
                         minimum height=2em, rounded corners=1mm]
  \tikzstyle{analyzer} =  [rectangle, draw, thin, fill=blue!20,%
                         minimum height=2em, rounded corners=1mm]

  \begin{figure}
  \begin{tikzpicture}[node distance=3cm, auto,>=latex', thick]
      % We need to set at bounding box first. Otherwise the diagram
      % will change position for each frame.
      \path[use as bounding box] (-1,0) rectangle (7,-2);
      \path[->]<1-> node[optimizer] (o1) {Optimization 1}
                    node[optimizer, right of=o1] (o2) {Optimization 2}
                    node[optimizer, right of=o2] (o3) {Optimization 3};
      \path[->]<2-> node[analyzer, below of=o1] (a1) {Analysis 1}
                    node[analyzer, below of=o2] (a2) {Alias Analysis}
                    node[analyzer, below of=o3] (a3) {Analysis 2}
                    (o1) edge (a1) edge (a2)
                    (o2) edge (a2) edge (a3)
                    (o3) edge (a2);
  \end{tikzpicture}
  \end{figure}

\end{frame}

\begin{frame}{Анализ синонимов и указателей}

  \begin{block}{Анализ синонимов (англ. \eng{Alias Analysis})}
    Могут ли два разных выражения ссылочного типа указывать на одно и то же
    место в памяти?
  \end{block}

  \begin{block}{Анализ указателей (англ. \eng{Points-To Analysis})}
    На какие объекты в памяти могут указывать выражения ссылочного типа?
  \end{block}

\end{frame}

\begin{frame}{Многопоточность}

  \begin{itemize}
    \item<1-> Алгоритму анализа указателей необходимо знать, какие значения
          могут быть прочитаны из полей объектов
    \item<1-> Проблемы с получением значений поля в многопоточных программах:
          \begin{itemize}
            \item<2-> поле может изменяться другими потоками
            \item<3-> изменение поля может быть не видно другим потокам
          \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Цель и задачи}

  \begin{itemize}
    \item Цель: разработка внутрипроцедурного алгоритма анализа указателей и
          внутреннего представления для использования в статическом
          оптимизирующем Java компиляторе Excelsior RVM
    \item Основные задачи:
      \begin{itemize}
        \item изучить существующие алгоритмы и выбрать подходящий
        \item адаптировать для анализа Java программ
        \item адаптировать для анализа многопоточных программ
        \item реализовать алгоритм в компиляторе Excelsior RVM
      \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Существующие алгоритмы}

  \begin{itemize}
    \item Алгоритм Андерсена\\сложность $O(N^3)$, более точный
    \item Алгоритм Стинсгарда\\сложность $O(N \alpha(N,N))$, менее точный\\
          {\small($\alpha(N,N)$~--- обратная функция Аккермана)}
  \end{itemize}

\end{frame}

\begin{frame}{C $\neq$ Java}

  \begin{columns}[t]
    \begin{column}{5cm}
      {\Large Язык C}

      $\textbf{int } *x = (\textbf{int } *)37 + 5;$

      \begin{itemize}
        \item есть адресная арифметика
        \item указатели на примитивы, объекты, \ldots
        \item объекты на стеке, в куче
        \item нестрогая типизация
      \end{itemize}
    \end{column}
    \begin{column}{5cm}
      {\Large Язык Java}

      $\textbf{Object } x = \textbf{new Object}();$

      \begin{itemize}
        \item нет адресной арифметики
        \item указатели только на объекты
        \item объекты только в куче
        \item строгая типизация
      \end{itemize}
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}{Java Memory Model}
  \begin{columns}[t]
    \begin{column}{5cm}
      \begin{block}{Чтение из \eng{volatile} поля}
        \begin{algorithmic}
          \STATE $a.x = 42$
          \STATE $\ldots$
          \STATE $t = b.volatile\_field$
          \STATE $\ldots$
          \STATE $x = a.x$
        \end{algorithmic}
      \end{block}
    \end{column}
    \begin{column}{5cm}
      \begin{block}{Чтение из обычного поля}
        \begin{algorithmic}
          \STATE $a.x = 42$
          \STATE $\ldots$
          \STATE $t = b.normal\_field$
          \STATE $\ldots$
          \STATE \only<1>{$x = a.x$}
                 \only<2>{\sout{$x = a.x$} $\Rightarrow$ $x = 42$}
        \end{algorithmic}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Практические результаты}

  Алгоритм реализован в статическом Java компиляторе и будет проведено
  сравнение следующих его модификаций:
  \begin{itemize}
      \item алгоритм анализа не адаптированный для многопоточных программ
      \item алгоритм анализа адаптированный для многопоточных программ
      \item алгоритм анализа адаптированный для многопоточных программ с
            учетом семантики final полей
  \end{itemize}
\end{frame}

\begin{frame}{Заключение}

  Сделано следующее:
  \begin{itemize}
    \item анализ существующих алгоритмов анализа указателей
    \item изучены особенности языка Java
    \item изучена спецификация модели памяти языка Java
    \item разработан алгоритм анализа указателей и внутреннее представление,
          адаптированные для анализа многопоточных Java программ
    \item реализован алгоритм анализа в рамках статического оптимизирующего
          Java компилятор Excelsior RVM
  \end{itemize}

\end{frame}

\begin{frame}

  \centering\huge

  Спасибо!

  Вопросы?

\end{frame}

\end{document}

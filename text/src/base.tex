\documentclass[14pt,titlepage]{extarticle}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{color}
\usepackage{algorithmic}

\title{
  Анализ указателей и синонимов для многопоточных программ
}
\author{
  Владимир Парфиненко
}

% поля и размер текста
\textwidth=17cm
\oddsidemargin=-8pt
\topmargin=0pt
\headheight=0pt
\headsep=0pt
\textheight=23cm
\linespread{1.3}

\bibliographystyle{gost780u}

%\newcommand{\remark}[1]{}
\newcommand{\remark}[1]{\textcolor{blue}{#1}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\newcommand{\eng}[1]{{\English#1}}

\newcommand{\underscore}[1]{\hbox to#1{\hrulefill}}

\begin{document}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %           Титульная страница
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \thispagestyle{empty}
  \begin {center}
    Министерство образования и науки

    Российской Федерации

    Федеральное агентство по образованию

    \vspace{0.3cm}

    Новосибирский государственный университет

    \vspace{0.3cm}

    Физический факультет

    Кафедра Автоматизации Физико-Технических Исследований

    \vspace {40mm}

    %Выпускная квалификационная работа бакалавра
    Октябрьский отчет

    \vspace {10mm}

    Парфиненко Владимир Владимирович

    \vspace {5mm}

    \textbf{АНАЛИЗ УКАЗАТЕЛЕЙ И СИНОНИМОВ\\ ДЛЯ МНОГОПОТОЧНЫХ ПРОГРАММ}

    \vspace {20mm}

    {\raggedleft

    Научный руководитель

    м.\,н.\,с.~ИСИ~СО~РАН, Павлов\,П.\,Е.

    \vspace {50mm}

    Новосибирск 2010}
  \end {center}


  \tableofcontents

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                  Введение
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \section{Введение}

    Средства оптимизации программ нужны для получения высокой
    скорости исполнения программ или улучшения других характеристик программы.

    Под оптимизацией программ понимается преобразование программы в
    семантически эквивалентную, но более эффективную относительно некоторого
    заданного критерия.
    Преобразование программы $A$ в программу $B$ эквивалентно (или корректно),
    если из того, что программа $A$ выполнима на некотором наборе данных,
    следует, что и $B$ также выполнима на этом наборе и дает тот же результат,
    что и $A$.
    В общем случае задача проверки эквивалентности двух программ неразрешима,
    и не существует алгоритма, который по данной программе находил бы
    эквивалентную ей и оптимальную относительно заданного критерия
    \cite{kasjanov_translators}.

    Тем не менее существует набор известных оптимизирующих преобразований,
    таких, что корректность каждого из них гарантирует корректность их
    последовательного применения.
    И чтобы конкретное преобразование данной программы было корректным,
    необходимо выполнение некоторых условий. Например, чтобы иметь
    возможность убрать генерацию некоторой части программы, нужно быть
    увереным, что управление никогда не попадет в эту часть программы.
    Для получения подобной информации используют результаты статического
    анализа. Анализируя код программы, деляются выводы о тех или иных свойствах
    программы, необходимых для корректности преобразования.

    Статический анализ применяется не только для проверки
    корректности преобразований, но и в инструментах статического анализа
    кода программ, которые могут находить потенциальные ошибки и определять
    другие свойства программы без ее непосредственного исполнения.

    Существует множество видов статического анализа, и одним из них
    является анализ указателей и синонимов.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%        Описание предметной области
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \section{Описание предметной области}

    Анализ указателей~--- это один из видов статического анализа, который
    позволяет определить на какие объекты в памяти могут указывать выражения
    ссылочного типа в программе. Анализ синонимов похож на анализ указателей,
    его целью является определение, могут ли два разных выражения ссылаться
    на одно и то же место в памяти (такие выражения называют синонимами).

    Существует множество алгоритмов анализа указателей и синонимов,
    одним из них является алгоритм анализа, основанный на типах
    (\eng{Type-Based Alias Analysis}) \cite{diwan_tbaa},
    применимый для языков со строгой типизацией.
    В языках со строгой типизацией допускается присваивание в переменную только
    значения, имеющего такой тип данных, что существует расширяющее
    преобразование к типу этой переменной.
    Например для языка Java, преобразование типа byte к типу int,
    преобразование ссылочного типа к его предку являются расширяющими
    преобразованиями, они безопасны и не требуют дополнительных действий
    на этапе исполнения.
    А преобразование типа double к типу float, преобразование типа
    Object к другому ссылочному типу являются сужающими, могут приводить к
    потере данных и требуют проверок на этапе исполнения.

    Простейшая реализация алгоритма основанного на типах полагается на то, что
    любая ссылочная переменная формального типа $T$ может указывать на любые
    объекты типа $T$ или его наследников. Такой алгоритм работает очень быстро,
    но обладает сравнительно низкой точностью.

    Для сравнения точности алгоритмов анализа указателей нам необходимо ввести
    некую меру точности. В качестве простой меры точности алгоритма можно
    использовать усредненное количество синонимов для переменных ссылочного
    типа, появляющихся в программе \cite{hind_pointer_analysis_not_solved_yet}.
    Понятно, что для «идеального» алгоритма анализа это число будет
    минимальным, а для самого консервативного алгоритма максимальным.

    Более точные алгоритмы анализа учитывают не только типы переменных,
    но и потоки данных в программе. Например, если существует только
    одно присваивание в переменную нового объекта типа $T$, выделенного в куче,
    то можно гарантировать, что эта переменная может указывать только
    на этот объект.
    С присваиванием значения одной переменной в другую ситуация сложнее.
    Рассмотрим следующий пример:
    \begin{algorithmic}[1]
    \STATE $b$ = new T()
    \STATE $c$ = new T()
    \STATE $a$ = $b$
    \STATE $a$ = $c$
    \end{algorithmic}
    Для удобства, множество объектов, на которые может указывать указатель $p$
    (или переменная ссылочного типа), обозначим как $Pts(p)$
    (англ. \eng{Points-to set}).
    Учитывая строки 1 и 2, для переменных $b$ и $c$ мы можем точно определить
    множество объектов, на которые они указывают,
    \[Pts(b) = \{O_1\}, Pts(c) = \{O_2\},\] где $O_1$ и $O_2$ уникальные
    объекты в куче. То есть мы уже учли поток данных от оператора new,
    вернувшего новый объект, в переменную.

    Интерпретировать присваивание $a = b$ можно двумя способами,
    и алгоритмы анализа разбиваются на два типа по этому признаку:
    \begin{itemize}
      \item алгоритмы первого типа накладывают ограничение
            $Pts(a) \supset Pts(b)$ (\eng{subset-based} алгоритмы),
      \item алгоритмы второго типа накладывают ограничение
            $Pts(a) = Pts(b)$ (\eng{equality-based} алгоритмы).
    \end{itemize}
    Первый тип алгоритмов более точен, в то время как второй быстрее
    \cite{steensgaard}. Возвращаясь к нашему примеры, \eng{subset-based}
    алгоритм получит, что
    \[Pts(a) = \{O_1, O_2\}, Pts(b) = \{O_1\}, Pts(c) = \{O_2\},\]
    а \eng{equality-based}
    \[Pts(a) = Pts(b) = Pts(c) = \{O_1, O_2\}.\]

    Рассмотрим, как алгоритм анализа может обрабатывать вызовы
    функций и процедур на следующем примере:
    \begin{algorithmic}[1]
    \STATE function foo($x$, $y$) \{ return $x$ \}
    \STATE $b$ = new T()
    \STATE $c$ = new T()
    \STATE $a$ = foo($b$, $c$)
    \end{algorithmic}
    Наша задача понять, чему равно $Pts(a)$.
    Алгоритмы анализа можно разделить на две категории, в зависимости от того,
    как они обрабатывают вызовы функций:
    \begin{itemize}
      \item межпроцедурные алгоритмы анализа могут сначал проанализировать
            тело вызываемой функции, и затем учесть результат при обработке
            вызова,
      \item внутрипроцедурные алгоритмы рассматривают вызов функции в наиболее
            консервативном предположении: может быть возвращен либо один из
            параметров, либо любой глобальный объект, либо новый объект.
    \end{itemize}
    Понятно, что первый тип алгоритмов дает более точные результаты,
    а второй потребляет меньше памяти и работает быстрее
    \cite[с.~117]{andersen}.
    В нашем примере межпроцедурный алгоритм анализа, проанализировав функцию
    foo, запоминает, что для нее выполнено следующее условие на возвращаемое
    значение
    \[Pts(retval) = Pts(x),\]
    и тогда может сделать вывод, что \[Pts(a) = Pts(b) = \{O_1\}.\]
    А внутрипроцедурный алгоритм анализа обязан сделать консервативное
    предположение \[Pts(a) = Pts(b) \cup Pts(c) = \{O_1, O_2\}.\]


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %             Постановка задачи
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \section{Постановка задачи}

    Целью данной работы является изучение существующих алгоритмов анализа
    указателей, последующее проектирование внутрипроцедурного алгоритма и
    внутренного представления для использования в оптимизирующем
    статическом компиляторе Java программ
    \eng{Excelsior Research Virtual Machine (Excelsior~RVM)}
    с учетом приведенных ниже требований.

    Алгоритм анализа должен учитывать следующие особенности языка Java:
    \begin{itemize}
      \item наличие строгой типизации,
      \item отсутствие адресной арифметики,
      \item отсутствие указателей на указатели.
    \end{itemize}
    При рассмотрении анализа указателей
    именно эти особенности отличают язык Java от языка C, для которого были
    спроектированны классические алгоритмы анализа указателей
    Стинсгарда \cite{steensgaard} и Андерсена \cite{andersen}.

    В свзяи с широким распространением многопоточных программ,
    алгоритм анализа необходимо адаптировать для применения к
    многопоточным программам согласно спецификации JVM, которая имеет
    строгое и подробное описание модели параллелизма.

    Кроме того внутреннее представление программы должно быть адаптировано,
    для хранения результатов анализа указателей, и предоставлять удобный
    интерфейс для получения этих результатов другими алгоритмами статического
    анализа.

    Для достижения поставленной цели необходимо:
    \begin{itemize}
      \item спроектировать внутрипроцедурный алгоритм анализа, учитывающий
            особенности языка Java и подходящий для анализа
            многопоточных Java программ,
      \item адаптировать существующее внутреннее представление программы для
            хранения результатов анализа указателей,
      \item реализовать алгоритм и внутреннее представление для оптимизирующего
            статического компилятора Java программ \eng{Excelsior RVM}.
    \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %             Список литературы
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \addcontentsline{toc}{section}{Список литературы}
  \bibliography{../../biblio}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %               План график
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \thispagestyle{empty}
  \pagestyle{empty}
  \section*{План-график}

    \begin{center}
      \begin{tabular}{|p{10.5cm}|c|c|}\hline
        \textbf{Задача}                       &\textbf{Время} & \textbf{Срок}\\
        \hline
        Прочитать кучу статей                 & (выполнено)   & 31.11 \\
        \hline
      \end{tabular}
    \end{center}



  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                  Оценки
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \thispagestyle{empty}
  \pagestyle{empty}
  \section*{Оценка за октябрьский отчёт}

    Руководитель: \underscore{1cm} (из 10 баллов).
    Подпись: \underscore{3cm} (Павлов\,П.\,Е.)

    \vspace{0.5cm}
    Преподаватель: \underscore{2cm}
\end{document}


\documentclass[14pt,titlepage]{extarticle}
\usepackage[pdftex,unicode,hidelinks]{hyperref}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[usenames,dvipsnames]{color}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{rotating}
\usepackage{array}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{gnuplot-lua-tikz}
\usepackage{subfig}
\usepackage{amsthm}

\usepackage[left=3cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\linespread{1.3}

\usepackage{numprint}
\newcommand{\num}[1]{\numprint{#1}}
  \npthousandsep{\,}
  \npthousandthpartsep{}
  \npdecimalsign{,}

\usepackage{tikz}
\usetikzlibrary{positioning,arrows,shapes}

\usepackage{footmisc}
\renewcommand\footnotelayout{\small}

\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

% used by bibliography:
\usepackage{datetime}
\newcommand{\usedate}[3]{({\Russian дата обращения: \formatdate{#1}{#2}{#3}})}
\bibliographystyle{gost71u2003}

%\setcounter{tocdepth}{2} % глубина оглавления

\floatname{algorithm}{Пример}
\newcommand{\algorithmictitle}[1]{\hspace{8mm}\textbf{#1}}
\renewcommand{\algorithmicrequire}{\textbf{Дано:}}
\renewcommand{\algorithmiccomment}[1]{// #1}
\newcommand{\NEW}{\textbf{new }}
\newcommand{\NEWi}[1]{\textbf{new}_{#1}\textbf{ }}
\newcommand{\NULL}{\textbf{null }}
\newcommand{\BOOLTRUE}{\textbf{true }}
\newcommand{\FUNCTION}{\textbf{function }}

\newcommand{\Type}[1]{\textrm{Type}(#1)}
\newcommand{\IsAssignable}[2]{\textrm{IsAssignable}(#1, #2)}
\newcommand{\Pts}[1]{\textrm{Pts}(#1)}
\newcommand{\VPts}[1]{\bar{#1}}
\newcommand{\OFPts}[2]{\overline{#1.#2}}
\newcommand{\Shared}{\overline{shared}}
\newcommand{\Filter}[2]{\textrm{Filter}_{#1}(#2)}
\newcommand{\cupe}{\,\cup\!\!=}

\let\oldphi\phi
\renewcommand{\phi}{\ensuremath{\oldphi}}

\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\newcommand{\incomp}{\not\lessgtr}

%\newcommand{\remark}[1]{}
%\newcommand{\todo}[1]{}
%\newcommand{\todocite}{}
\newcommand{\remark}[1]{\textcolor{Green}{(#1)}}
\newcommand{\todo}[1]{\textcolor{red}{(\eng{TODO}: #1)}}
\newcommand{\todocite}{[\textcolor{red}{\eng{cite}}]}

\newcommand{\eng}[1]{{\English#1}}
\newcommand{\engdef}[1]{(англ.~\eng{#1})}

\addto\captionsrussian{
  \let\oldrefname\refname
  \renewcommand\refname{\addcontentsline{toc}{section}{\oldrefname}\oldrefname}
}

% русские нумераторы
\renewcommand{\theenumii}{(\asbuk{enumii})}
\renewcommand{\labelenumii}{\asbuk{enumii})}
\renewcommand{\thesubfigure}{\asbuk{subfigure}}


% обёртка с моими настройками поверх figure:
% \begin{myfigure}{подпись}{label} ... \end{myfigure}
\newenvironment{myfigure}[2]%
  {\pushQED{\caption{#1} \label{#2}} % push caption & label
   \begin{figure}[!htb]\centering } %
  {  \popQED % pop caption & label
   \end{figure}}
\newenvironment{myplot}[2]%
  {\pushQED{\caption{#1} \label{#2}} % push caption & label
   \begin{figure}[p]\centering\small } %
  {  \popQED % pop caption & label
   \end{figure}}

%\newcommand{\inputplot}[1]{\input{#1}}
\newcommand{\inputplot}[1]{Here would be plot}

\let\oldsection\section
\renewcommand{\section}{\newpage\oldsection}

\newcommand{\sectionwithoutnumber}[1]{
  \section*{#1}
  \addcontentsline{toc}{section}{#1}
}

\newcommand{\java}{\eng{Java}\xspace}

\title{
  Анализ указателей и синонимов для многопоточных программ
}
\author{
  Владимир Парфиненко
}

\begin{document}

  \thispagestyle{empty}
  \begin{center}

    Министерство образования и науки\\
    Российской Федерации

    \vspace{0.7cm}

    Государственное образовательное учреждение\\
    высшего профессионального образования\\
    «Новосибирский государственный университет» (НГУ)

    \vspace{0.7cm}

    Физический факультет

    \vspace{0.2cm}

    Кафедра автоматизации физико-технических исследований

    \vspace{1.2cm}

    Квалификационная работа на соискание\\
    степени бакалавра

    \vspace{0.2cm}

    Парфиненко Владимир Владимирович

    \vspace{1.5cm}

    \textbf{АНАЛИЗ УКАЗАТЕЛЕЙ И СИНОНИМОВ\\ ДЛЯ МНОГОПОТОЧНЫХ ПРОГРАММ}

    \vspace{2.5cm}

    \begin{flushright}

      Научный руководитель

      м.\,н.\,с.~ИСИ~СО~РАН, Павлов\,П.\,Е.

    \end{flushright}

    \vspace {4cm}

    Новосибирск 2011
  \end{center}

  \tableofcontents

  \sectionwithoutnumber{Введение}

    Средства оптимизации программ нужны для получения высокой
    скорости их исполнения или улучшения других характеристик.

    Под оптимизацией программы понимается ее преобразование в
    семантически эквивалентную, но более эффективную относительно некоторого
    заданного критерия.
    Преобразование программы $A$ в программу $B$ корректно, если эти программы
    эквивалентны: они выполнимы на одном и том же наборе входных данных и дают
    одинаковые результаты на этих данных.
    В общем случае задача проверки эквивалентности двух программ неразрешима,
    то есть не существует алгоритма, который по данной программе находил бы
    эквивалентную ей и оптимальную относительно заданного
    критерия~\cite{kasjanov_translators}.

    Тем не менее существует набор известных оптимизирующих преобразований,
    таких, что корректность каждого из них гарантирует корректность их
    последовательного применения.
    И чтобы конкретное преобразование данной программы было корректным,
    необходимо выполнение некоторых условий. Например, чтобы иметь
    возможность убрать некоторую часть программы, достаточно знать, что
    управление никогда не попадет в эту часть программы.
    Для получения подобной информации используют результаты статического
    анализа. Анализируя код программы, делаются выводы о тех или иных свойствах
    программы, необходимых для проведения преобразования.

    Статический анализ применяется не только для проверки
    корректности преобразований, но и в инструментах статического анализа
    кода, которые могут находить потенциальные ошибки и определять
    другие свойства программы без ее непосредственного исполнения.

    Существует множество видов статического анализа, в данной работе
    рассматриваются анализ указателей и анализ синонимов.

  \section{Анализ указателей и синонимов}

    Анализ указателей~--- это один из видов статического анализа, который
    позволяет определить, на какие объекты в памяти могут указывать выражения
    ссылочного типа в программе (такие объекты называются целями выражения
    ссылочного типа). Анализ синонимов похож на анализ указателей: его целью
    является определение, могут ли два разных выражения ссылаться на одно и
    то же место в памяти (такие выражения называют синонимами)~\cite{andersen}.

    \subsection{Классификация алгоритмов анализа указателей}
    \label{section:analysis_classification}

      Разные алгоритмы анализа указателей отличаются по точности, по скорости
      работы, по количеству памяти, необходимой для проведения анализа.
      Далее будут рассмотрены основные параметры алгоритмов, влияющие на эти
      характеристики.

      Для сравнения точности алгоритмов анализа указателей необходимо ввести
      некую меру точности. В качестве простой меры точности алгоритма часто
      используется усредненное количество синонимов для всех переменных
      ссылочного типа, появляющихся в
      программе~\cite[раздел~3.2]{hind_pointer_analysis_not_solved_yet}
      (также существуют и более изощренные
      меры~\cite{hind_pointer_analysis_not_solved_yet,diwan_tbaa}).

      Понятно, что для «идеального» алгоритма анализа это число будет
      минимальным, а для самого консервативного алгоритма максимальным.

      \subsubsection{Чувствительные к потоку данных алгоритмы}
        \label{section:analysis_classification_data_flow}

        Примером алгоритма, не учитывающего потоки данных в программе, может
        служить алгоритм анализа синонимов, основанный на типах, применимый
        для языков со строгой типизацией (подробнее про строгую систему типов в
        разделе~\ref{section:type_system})
        Простейшая реализация такого алгоритма дает следующий результат:
        независимо от контекста и потоков данных в программе, два выражения
        могут быть синонимами, если они имеют совместимые формальные
        типы~\cite[раздел~2.2]{diwan_tbaa}.
        Такой алгоритм работает за константное время, но обладает очень низкой
        точностью.

        Большей точностью обладают алгоритмы анализа, которые учитывают потоки
        данных в программе.
        Например, если существует только одно присваивание переменной $v$ вида
        $v = \NEW T()$, то можно гарантировать, что переменная $v$ может
        указывать только на объект, созданный этим оператором \eng{new}.
        С присваиванием вида $v_1 = v_2$ ситуация сложнее. Рассмотрим
        пример~\ref{code:data_flow}.
        \begin{algorithm}
          \caption{Сравнение алгоритмов \eng{subset-based} и
                                        \eng{equality-based} типов}
          \label{code:data_flow}
          \begin{algorithmic}[1]
            \STATE $b$ = \NEW T()
            \STATE $c$ = \NEW T()
            \STATE $a$ = $b$
            \STATE $a$ = $c$
          \end{algorithmic}
        \end{algorithm}

        Цели указателя, то есть множество объектов, на которые может указывать
        переменная $p$ (или любое другое выражение ссылочного типа), для
        удобства обозначим как $Pts(p)$ \engdef{points-to set}.
        Учитывая строки 1 и 2, для переменных $b$ и $c$ мы можем точно
        определить множество объектов, на которые они указывают:
        \[Pts(b) = \{O_1\}, Pts(c) = \{O_2\},\]
        где $O_1$ и $O_2$~--- уникальные объекты в куче, соответствующие
        операторам \eng{new} в строках 1 и 2.  То есть мы учли поток данных от
        оператора \eng{new}, создавшего новый объект, в переменную.

        Интерпретировать присваивание $a = b$ можно двумя способами,
        и алгоритмы анализа разбиваются на два типа по этому признаку:
        \begin{itemize}
          \item алгоритмы первого типа накладывают ограничение
                $Pts(a) \supset Pts(b)$
                (\eng{subset-based} алгоритмы)~\cite{andersen}
          \item алгоритмы второго типа накладывают ограничение
                $Pts(a) = Pts(b)$
                (\eng{equality-based} алгоритмы)~\cite{steensgaard}
        \end{itemize}
        В нашем примере \eng{subset-based} алгоритм получит, что
        \[Pts(a) = \{O_1, O_2\}, Pts(b) = \{O_1\}, Pts(c) = \{O_2\},\]
        а \eng{equality-based}
        \[Pts(a) = Pts(b) = Pts(c) = \{O_1, O_2\}.\]
        Первый тип алгоритмов более точен, хотя его время работы в худшем
        случае кубически зависит от размера анализируемой программы.
        Второй тип алгоритмов работает за практически линейное время\footnote{
          Временная сложность \eng{equality-based} алгоритма
          $O(N \alpha(N))$~\cite{steensgaard}, где $\alpha(N)$~--- обратная
          функция Аккермана. Она является очень медленно растущей, и при
          анализе асимптотики алгоритмов можно принять ее за константу.
        },
        предоставляя менее точные результаты.
        Каждый из этих алгоритмов имеет свою область применения, например,
        \eng{subset-based} алгоритм имеет смысл использовать при анализе
        отдельного метода программы, в то время как \eng{equality-based} лучше
        подходит для анализа всей программы целиком.


      \subsubsection{Чувствительные к потоку управления алгоритмы}
        \label{section:analysis_classification_control_flow}

        Также для повышения точности алгоритм анализа указателей может
        учитывать поток управления в программе.
        Рассмотрим пример~\ref{code:control_flow}.
        \begin{algorithm}
          \caption{Сравнение чувствительного и нечувствительного к потоку
                   управления алгоритмов}
          \label{code:control_flow}
          \begin{algorithmic}[1]
            \STATE $a$ = \NEW T()
            \STATE $b$ = \NEW T()
            \STATE $c$ = \NEW T()
            \STATE $a$ = $b$
            \STATE $b$ = $c$
            \STATE $c$ = $a$
          \end{algorithmic}
        \end{algorithm}

        Нечувствительный к потоку управления алгоритм анализа воспринимает
        программу как неупорядоченный набор операций.
        Для указанного примера такой алгоритм получит следующее
        \[Pts(a) = Pts(b) = Pts(c) = \{O_a, O_b, O_c\}.\]
        Этот результат не является особо точным, но зато он верен
        для любой точки программы.

        Чувствительный к потоку управления алгоритм получит следующие данные
        после 3-ей строки
        \[\textrm{строка 3}:
            Pts(a) = \{O_a\}, Pts(b) = \{O_b\}, Pts(c) = \{O_c\}.\]
        Далее, при анализе 4-ой строки, присваивание будет интерпретировано
        как строгое присваивание (подробнее в
        разделе~\ref{section:flow_sensetive_analysis}), и алгоритм получит
        результат, что $Pts(a) = \{O_b\}$. То есть присваивание нового значения
        в переменную уничтожило информацию о том, что $a$ может указывать на
        $O_a$. Продолжая подобные рассуждения до последней строки, получаются
        следующие результаты:
        \[\textrm{строка 6}:
            Pts(a) = \{O_b\}, Pts(b) = \{O_c\}, Pts(c) = \{O_b\}.\]
        Хотя такой алгоритм дает более точный результат, приходится хранить
        информацию о целях каждого указателя для каждой точки программы
        отдельно, что значительно увеличивает суммарный объем памяти,
        занимаемый результатами анализа.

      \subsubsection{Межпроцедурные алгоритмы}

        Алгоритм анализа может учитывать потоки данных не только внутри
        единственной анализируемой функции, но и между отдельными функциями,
        которые могут быть вызваны из анализируемой.
        Рассмотрим пример~\ref{code:interprocedural}.
        \begin{algorithm}
          \caption{Демонстрация работы межпроцедурного алгоритма}
          \label{code:interprocedural}
          \begin{algorithmic}[1]
            \STATE \FUNCTION foo($x$, $y$) \{
            \RETURN $x$
            \STATE \}
            \STATE
            \STATE $b$ = \NEW T()
            \STATE $c$ = \NEW T()
            \STATE $a$ = foo($b$, $c$)
          \end{algorithmic}
        \end{algorithm}

        Наша задача понять, чему равно $Pts(a)$.
        Алгоритмы анализа можно разделить на две категории, в зависимости от
        того, как они обрабатывают вызовы функций:
        \begin{itemize}
          \item межпроцедурные алгоритмы анализа могут сначала проанализировать
                тело вызываемой функции, и затем учесть результат при обработке
                вызова,
          \item внутрипроцедурные алгоритмы рассматривают вызов функции в
                наиболее консервативном предположении: может быть возвращен
                либо один из параметров, либо один из глобальных объектов.
        \end{itemize}
        Понятно, что первый тип алгоритмов дает более точные результаты,
        а второй потребляет меньше памяти и работает
        быстрее~\cite[с.~117]{andersen}.
        В нашем примере межпроцедурный алгоритм анализа, проанализировав
        функцию \eng{foo}, запоминает, что для нее выполнено следующее условие
        на возвращаемое значение
        \[Pts(retval) = Pts(x),\]
        и тогда может сделать вывод, что \[Pts(a) = Pts(b) = \{O_1\}.\]
        В такой же ситуации внутрипроцедурный алгоритм анализа обязан сделать
        консервативное предположение
        \[Pts(a) = Pts(b) \cup Pts(c) = \{O_1, O_2\}.\]

  \section{Описание предметной области}

    \subsection{Место алгоритмов анализа в компиляторе}

      Рассмотрим общую архитектуру оптимизирующего статического компилятора.

      \begin{myfigure}%
        {Архитектура оптимизирующего статического компилятора (оранжевые~---
         преобразователи, зеленые~--- представления, синие~--- оптимизаторы)}%
        {fig:arch}

        \tikzstyle{converter} = [rectangle, draw, thin, fill=orange!20,
                            minimum height=2em, rounded corners=3mm,
                            text width=1.2cm, text centered]

        \tikzstyle{representation} = [circle, draw, thin, fill=green!20,
                            minimum height=2em,
                            text width=1.2cm, text centered]

        \tikzstyle{optimizer} = [rectangle, draw, thin, fill=blue!10,
                            minimum height=2em,
                            text width=2.6cm, text centered]

        \begin{tikzpicture}[auto,>=latex', thick]
          \path[->] node[representation] (src) {SRC}
                    node                 (d1)  [right=0.75cm of src] {}
                    node[representation] (ast) [right=1.8cm of src] {AST}
                    node                 (d2)  [right=0.75cm of ast] {}
                    node[representation] (cfg) [right=1.8cm of ast] {CFG}
                    node                 (d3)  [right=0.75cm of cfg] {}
                    node[representation] (asm) [right=1.8cm of cfg] {ASM}
                    node                 (d4)  [right=0.75cm of asm] {}
                    node[representation] (obj) [right=1.8cm of asm] {OBJ}
                    node[optimizer] (high)   [below=1cm of ast] {High-level Optimizer}
                    node[optimizer] (middle) [below=1cm of cfg] {Middle-level Optimizer}
                    node[optimizer] (low)    [below=1cm of asm] {Low-level Optimizer}
                    node[converter] (c1)  [above=1.5cm of d1,text width=2.2cm] {Front-end}
                    node[converter] (c2)  [above=1.5cm of d2] {}
                    node[converter] (c3)  [above=1.5cm of d3,text width=2.2cm] {Code generator}
                    node[converter] (c4)  [above=1.5cm of d4] {}
                    (src) edge (c1)
                    (c1) edge (ast)
                    (ast) edge (c2)
                    (c2) edge (cfg)
                    (cfg) edge (c3)
                    (c3) edge (asm)
                    (asm) edge (c4)
                    (c4) edge (obj)
                    (ast) edge [<->] (high)
                    (cfg) edge [<->] (middle)
                    (asm) edge [<->] (low)
                    ;
        \end{tikzpicture}
      \end{myfigure}

      Такой компилятор представляет из себя конвейер (см.~рис.~\ref{fig:arch}):
      на входе он получает исходный код программы, на выходе отдает код целевой
      машины.
      Также существуют промежуточные представления, пригодные для работы
      оптимизаторов и необходимых им алгоритмов анализа.

      Для перевода программы из одного представления в другое существуют
      преобразователи.
      Самый первый преобразователь переводит исходный код программы
      или байт-код программы (в случае \java)
      во внутреннее представление, с которым удобно работать другим
      компонентам компилятора.
      Последний преобразователь выполняет перевод в самое низкоуровневое
      представление, содержащее данные и код, пригодный для исполнения
      на целевой машине.

      Оптимизации проводятся на одном из внутренних представлений, они
      модифицируют его с целью повышения эффективности исполнения программы
      относительно заданного критерия. Однако, эти преобразования должны быть
      корректными. Информацию о том, возможно ли проведение данного
      преобразования, преобразователи получают от анализаторов, вспомогательных
      компонент, которые проводят статический анализ программы и могут
      предоставлять ту или иную информацию о ее свойствах
      (см.~рис.~\ref{fig:optimizators}).

      \begin{myfigure}%
        {Оптимизаторы и анализаторы}%
        {fig:optimizators}

        \tikzstyle{optimizer} = [rectangle, draw, thin, fill=red!15,
                            minimum height=2em, rounded corners=1mm,
                            text width=3cm, text centered]
        \tikzstyle{analyzer} =  [rectangle, draw, thin, fill=yellow!20,
                            minimum height=2em, rounded corners=1mm,
                            text width=3cm, text centered]

        \begin{tikzpicture}[node distance=2.5cm, auto,>=latex', thick]
          \path[->] node[optimizer] (o1) {Common Subexpression Elimination}
                    node[optimizer] (o2) [right=of o1] {Constant Propagation}
                    node[optimizer] (o3) [right=of o2] {Loop Invariant Code Motion};
          \path[->] node[analyzer]  (a1) [below=of o1] {Escape Analysis}
                    node[analyzer]  (a2) [right=of a1, line width=0.5mm] {Alias Analysis}
                    node[analyzer]  (a3) [right=of a2] {Control Flow Analysis}
                    (o1) edge (a2)
                    (o2) edge (a1) edge (a3)
                    (o3) edge (a2) edge (a3)
                    (a1) edge (a2);
        \end{tikzpicture}
      \end{myfigure}

      Рассмотрим оптимизацию выноса инвариантов цикла \engdef{loop invariant
      code motion} на примере~\ref{code:licm}.
      Для выноса какого-либо выражения из цикла, требуется убедиться, что оно
      не будет изменяться (является инвариантом цикла).
      В данном примере, кандидатом на вынесение из цикла является выражение
      $x.field$. Оптимизатору необходимо убедиться, что поле объекта, на
      который ссылается переменная $x$, не изменяется при выполнении других
      операций в теле цикла. В данном примере оптимизатору необходимо знать,
      могут ли переменные $x$ и $y$ быть синонимами. Если могут, то
      проводить преобразование нельзя, так как запись в $y.field$ может
      изменить значение $x.field$. Если же переменные точно не являются
      синонимами, то вынос $x.field$ из цикла является корректным
      преобразованием.

      \begin{algorithm}
        \caption{Вынесение инвариантов цикла}
        \label{code:licm}
        \begin{multicols}{2}
          \algorithmictitle{Исходный код}
          \begin{algorithmic}[1]
            \FOR{$i = 1$ to \textbf{length}($a$)}
            \STATE $y.field = func(i)$
            \STATE $a[i] = x.field$
            \ENDFOR
          \end{algorithmic}
          \columnbreak
          \algorithmictitle{Преобразованный код}
          \begin{algorithmic}[1]
            \STATE $temp = x.field$
            \FOR{$i = 1$ to \textbf{length}($a$)}
            \STATE $y.field = func(i)$
            \STATE $a[i] = temp$
            \ENDFOR
          \end{algorithmic}
        \end{multicols}
      \end{algorithm}

      Анализ синонимов, описанный в работе, позволяет отвечать на
      вопрос оптимизатора: «Могут ли две переменные ссылочного типа быть
      синонимами?»

    \subsection{Анализ многопоточных программ}
      \label{section:intro_to_multithreading}

      Компьютеры, в которых несколько процессоров взаимодействуют с
      использованием разделяемой памяти, разрабатываются с 1960-х годов, а
      сейчас они уже распространены повсеместно.

      С одной стороны, изначально доступ к общей памяти был строго
      последовательным для всех потоков, исполнявшихся на разных процессорах.
      Это приводило к тому, что два последовательных чтения в одном потоке из
      одного и того же места памяти могли давать разные результаты, так как в
      параллельном потоке могла быть совершена запись в эту же самую память в
      момент времени между последовательными чтениями в первом потоке.

      С другой стороны, со временем появились весьма изощренные техники
      повышения производительности работы с общей памятью: многоуровневые кэши,
      внеочередное исполнение \engdef{out-of-order execution} и другие.
      Это приводит к тому, что запись в память, произведенная одним потоком,
      может быть не видна другим. Или наоборот: запись может произойти раньше
      либо позже по сравнению со строго последовательным порядком исполнения.

      Рассмотрим пример~\ref{code:out_of_order_exec}, исполнение которого на
      современном процессоре может привести к неожиданному результату.
      Если изначально $obj.x = obj.y = 0$, то по окончанию работы примера
      значения переменных $x$ и $y$ могут равняться также нулю. Это связано с
      тем, что процессор при исполнении первого потока мог сначала выполнить
      вторую операцию, так как она не зависит от первой, аналогично при
      исполнении второго потока.

      \begin{algorithm}
        \caption{Нарушение логики программы при внеочередном исполнении}
        \label{code:out_of_order_exec}
        \begin{multicols}{2}
          \algorithmictitle{Поток 1}
          \begin{algorithmic}[1]
            \STATE $obj.x = 1$
            \STATE $y = obj.y$
          \end{algorithmic}
          \columnbreak
          \algorithmictitle{Поток 2}
          \begin{algorithmic}[1]
            \STATE $obj.y = 1$
            \STATE $x = obj.x$
          \end{algorithmic}
        \end{multicols}
      \end{algorithm}

      Получается, что если нет четкой семантики, определяющей, какие значения
      могут быть получены при чтении переменных из памяти, анализ указателей
      для них получится очень неточным\footnote{
        В такой ситуации алгоритму анализа придется делать очень консервативное
        предположение: считать, что все указатели, прочитанные из памяти, могут
        указывать на одни и те же данные и могут быть синонимами.
      } и не будет давать хоть сколько-нибудь полезной информации, что приведет
      к невозможности проведения большого количества оптимизирующих
      преобразований программы.

      На самом деле в большинстве систем есть определенные правила,
      регулирующие работу с памятью. Такие правила есть на уровне процессора,
      виртуальной машины и языка. Эти правила называют моделью памяти.
      Модель памяти для многопоточной системы определяет в каком
      порядке могут происходить доступы к памяти в программе и, как следствие,
      какие значения может возвращать конкретное чтение памяти. Соответственно,
      наличие четко определенной модели памяти позволяет разработать алгоритм
      анализа, пригодный для анализа многопоточных программ.

  \section{Постановка задачи}

    Целью данной работы является разработка внутрипроцедурного алгоритма
    анализа указателей и внутреннего представления программы для использования
    в оптимизирующем статическом компиляторе \java-программ \eng{Excelsior
    Research Virtual Machine (Excelsior~RVM)}~\cite{excelsior_jet} с учетом
    приведенных ниже требований.

    Алгоритм анализа должен учитывать следующие особенности языка \java:
    \begin{itemize}
      \item наличие строгой типизации,
      \item указатели только на объекты в куче,
      \item отсутствие адресной арифметики.
    \end{itemize}
    Именно эти особенности отличают язык \java от языка C, для которого были
    разработаны классические алгоритмы анализа указателей
    Стинсгарда~\cite{steensgaard} и Андерсена~\cite{andersen}.

    В связи с широким распространением многопоточных программ, алгоритм анализа
    необходимо адаптировать согласно спецификации языка \java, которая имеет
    строгое и подробное описание модели памяти~\cite{manson_jmm}.

    Кроме того, внутреннее представление программы должно быть подходящим для
    эффективного проведения анализа и хранения его результатов с возможностью
    быстрого доступа к ним.

    Для достижения поставленной цели необходимо:
    \begin{itemize}
      \item изучить существующие алгоритмы анализа указателей,
      \item выбрать один из существующих алгоритмов анализа и, изучив
            спецификацию языка \java и его виртуальной машины, адаптировать
            алгоритм для анализа многопоточных программ на языке \java,
      \item разработать внутреннее представление программы для эффективной
            работы алгоритма анализа и хранения его результатов,
      \item реализовать алгоритм и внутреннее представление в рамках
            оптимизирующего статического компилятора \java программ
            \eng{Excelsior~RVM}.
    \end{itemize}

  \section{Внутреннее представление и SSA-форма}
    \label{section:ir_and_ssa}

    В данном разделе будут введены понятия внутреннего представления программы
    и SSA-формы программы, которые понадобятся в дальнейшем при описании
    алгоритма анализа указателей.

    В процессе компиляции программа на исходном языке программирования
    переводится в так называемое внутреннее представление
    \engdef{internal representation, IR}, c которым работают
    алгоритмы анализа и над котором проводятся оптимизации.
    Рассмотрим внутреннее представление тела функции, заданное в виде
    управляющего графа \engdef{control flow graph, CFG}, именно это
    внутреннее представление используется для проведения большинства
    оптимизаций в современных компиляторах~\cite{muchnick}.
    CFG~--- это ориентированный граф, в котором вершинам соответствуют
    последовательности операторов программы, а дугам~--- переходы из конца
    одной последовательности операторов в начало другой. Такие
    последовательности операторов, являющиеся вершинами, назовем линейными
    участками. В конце каждого линейного участка присутствует оператор
    перехода, который передает управление по одной из дуг, выходящих из
    данной вершины CFG.

    Будем говорить, что программа находится в SSA-форме (\eng{Static Single
    Assignment}), если существует не более одного присваивания в любую из
    переменных~\cite{ssa}.
    Для представления программ в SSA-форме переменные версионируются и
    вводится дополнительная операция слияния значений переменных, так
    называемая \phi-функция.

    Версии вводятся для переменных, которые имеют более одного присваивания.
    Участок программы вида
    \[ v = 1; \textrm{use}(v); v = 2; \textrm{use}(v); \]
    после версионирования будет выглядеть следующим образом
    \[ v_1 = 1; \textrm{use}(v_1); v_2 = 2; \textrm{use}(v_2); \]

    \phi-функции вводятся для слияния версий переменных, определяемых
    на разных путях исполнения. Пусть в CFG программы существует
    вершина $N$, такая что в нее входят дуги из вершин $N_1, \ldots, N_k$, в
    которых использовались версии $v_1, \ldots, v_k$ переменной $v$. Тогда в
    $N$ будет располагаться \phi-функция
    \[ v_x = \phi(v_1, \ldots, v_k). \]
    Семантика данной операции заключается в присваивании переменной $v_x$
    значения переменной $v_i$, соответствующего вершине $N_i$, из которой
    управление пришло в $N$. В случае программы, приведенной в
    примере~\ref{code:ssa_with_phi}, переменной $a_3$ будет присвоено значение
    5 или 7, в зависимости от того, из какой ветки условного блока придет
    исполнение.

    \begin{algorithm}
      \caption{Пример перевода программы в SSA-форму с \phi-функцией}
      \label{code:ssa_with_phi}
      \begin{multicols}{2}
        \begin{algorithmic}[1]
          \IF{\ldots}
            \STATE $a = 5$
          \ELSE
            \STATE $a = 7$
          \ENDIF
          \STATE $\textrm{use}(a)$
        \end{algorithmic}
        \columnbreak
        \begin{algorithmic}[1]
          \IF{\ldots}
            \STATE $a_1 = 5$
          \ELSE
            \STATE $a_2 = 7$
          \ENDIF
          \STATE $a_3 = \phi(a_1, a_2)$
          \STATE $\textrm{use}(a_3)$
        \end{algorithmic}
      \end{multicols}
    \end{algorithm}

    Любую программу можно перевести в SSA-форму посредством
    версионирования переменных и расстановки \phi-функций~\cite{ssa}.
    Для перевода в SSA-форму и вывода из нее существуют эффективные
    алгоритмы~\cite{bilardi_ssa, briggs_ssa}.

  \section{Алгоритм анализа указателей}
    \label{section:algorithm}

    В данном разделе будет описан разработанный алгоритм анализа указателей.
    Сначала будет определен тип алгоритма в соответствии с классификацией,
    представленной в разделе~\ref{section:analysis_classification}.
    Затем будет дано описание основной идеи алгоритма.
    После этого будут описаны особенности алгоритма, связанные с
    многопоточностью и системой типов языка.
    И наконец, будет описано использование алгоритма в рамках набора операций
    языка \java.

    \subsection{Тип алгоритма}

      Необходимо определиться с характеристиками алгоритма анализа,
      подходящего для нашей задачи. Описание основных характеристик уже было
      приведено в разделе~\ref{section:analysis_classification}.

      \subsubsection{Внутрипроцедурный алгоритм анализа}

        Хотя межпроцедурные алгоритмы анализа указателей и дают более точные
        результаты, они сложны для реализации, тем более для таких
        языков как \java, где большинство методов являются виртуальными.
        Реализация такого алгоритма анализа выходит за рамки моей
        квалификационной работы, в ней рассматривается внутрипроцедурный
        алгоритм. Однако отсутствие межпроцедурного анализа смягчается тем, что
        до вызова алгоритма анализа указателей может быть проведена
        оптимизация открытой подстановки методов.

      \subsubsection{\texorpdfstring{\eng{Subset-based} алгоритм анализа}
                                    {Subset-based алгоритм анализа}}

        Как уже было показано в
        разделе~\ref{section:analysis_classification_data_flow}
        алгоритмы анализа, не учитывающие потоки данных в анализируемой
        программе, обладают очень низкой точностью, что не является
        удовлетворительным для данной работы. Поэтому далее будем рассматривать
        только алгоритмы, учитывающие потоки данных.

        Среди алгоритмов, учитывающих потоки данных, также существует выбор
        между типом алгоритма: \eng{subset-based} или \eng{equality-based}.
        При таком выборе необходимо решить, что важнее в конкретном
        случае: точность или скорость работы, соответственно.
        Хотя время работы \eng{subset-based} алгоритма в худшем случае
        кубически зависит от размеров программы, а для \eng{equality-based}
        практически линейно, проведенные
        эксперименты~\cite{shapiro_fast_and_accurate} показывают, что на
        небольших программах (до \num{3000} строк), время работы обоих
        алгоритмов анализа примерно одинаково, но точность у \eng{subset-based}
        алгоритма значительно выше.

        Заметим, что отдельный метод программы разумно отнести к <<небольшим
        программам>>, поэтому при использовании внутрипроцедурного алгоритма
        \eng{subset-based} типа, мы получим весомый выигрыш в точности анализа
        при незначительных потерях во времени. Соответственно, в данной работе
        будет использоваться именно этот тип алгоритма.

      \subsubsection{Нечувствительный к потоку алгоритм анализа}
        \label{section:flow_sensetive_analysis}

        Рассмотрим другую характеристику алгоритма анализа указателей:
        чувствительность к потоку управления в программе.
        Алгоритм анализа, чувствительный к потоку управления, дает более точные
        результаты, при этом потребляя значительно больше ресурсов, таких как
        память и
        время~\cite[раздел.~4.4]{hind_pointer_analysis_not_solved_yet}.

        Напомним, что точность чувствительного к потоку алгоритма во многом
        обусловлена эффектом строгих присваиваний \engdef{strong update}.
        Строгое присваивание, по возможности заменяет текущий набор целей
        указателя на новый, а не просто расширяет его.
        Однако известно, что эффекта строгого присваивания для переменных
        верхнего уровня можно добиться, переведя программу в
        SSA-форму~\cite{points_to_with_efficient_strong_updates}.

        Продемонстрируем работу нечувствительного к потоку алгоритма на
        примере~\ref{code:ssa_precision} (это пример~\ref{code:control_flow},
        переведенный в SSA-форму).
        \begin{algorithm}
          \caption{Повышение точности за счет использования SSA-формы}
          \label{code:ssa_precision}
          \begin{algorithmic}[1]
            \REQUIRE $x_0, x_1, \ldots, x_i, \ldots$~--- версии одной переменной $x$
            \STATE $a_0$ = \NEW T()
            \STATE $b_0$ = \NEW T()
            \STATE $c_0$ = \NEW T()
            \STATE $a_1$ = $b_0$
            \STATE $b_1$ = $c_0$
            \STATE $c_1$ = $a_1$
          \end{algorithmic}
        \end{algorithm}

        Так как присутствует только одно присваивание каждой переменной, легко
        получается следующий результат:
        \[Pts(a_0) = \{O_a\}, Pts(b_0) = \{O_b\}, Pts(c_0) = \{O_c\},\]
        \[Pts(a_1) = \{O_b\}, Pts(b_1) = \{O_c\}, Pts(c_1) = \{O_b\}.\]
        Как было показано в
        разделе~\ref{section:analysis_classification_control_flow},
        чувствительный к потоку алгоритм анализа дает идентичный результат для
        конечной точки примера~\ref{code:control_flow} (учитывая, что для
        конечной точки программы $a = a_1$, $b = b_1$, $c = c_1$):
        \[Pts(a) = \{O_b\}, Pts(b) = \{O_c\}, Pts(c) = \{O_b\}.\]

        В итоге, в данной работе будет использован нечувствительный к потоку
        управления алгоритм. Этот выбор обусловлен, во-первых,
        неудовлетворительным потреблением ресурсов чувствительными к потоку
        алгоритмами и, во-вторых, сложностью реализации подобных алгоритмов.
        Недостаток точности будет отчасти нивелирован использованием SSA-формы
        программы, которая уже используется в большинстве современных
        компиляторов и в \eng{Excelsior~RVM} в том числе.

    \subsection{Основа алгоритма анализа}
      \label{section:algorithm_basis}

      В этом разделе описана основная идея внутрипроцедурного,
      нечувствительного к потоку управления алгоритма анализа указателей
      \eng{subset-based} типа, работающего с программой в SSA-форме. Основа
      алгоритма идентична внутрипроцедурному алгоритму анализа Андерсена для
      языка C, представленному в работе~\cite{andersen}.

      Алгоритм анализа работает с выражениями ссылочного типа, каждое из
      которых имеет множество целей. Это множество состоит из абстрактных
      объектов, которые соответствуют объектам кучи в анализируемой программе.
      Объекты могут либо создаваться в анализируемом методе с помощью оператора
      \eng{new}, либо приходить извне.

      Введем следующее обозначение для множества целей выражения $expr$:
      $\Pts{expr} = \{O_1, O_2, \ldots, O_n\}$, где $O_i$~--- абстрактные
      объекты.

      В рамках анализа указателей достаточно рассматривать только те операции
      анализируемой программы, которые модифицируют множества целей выражений.
      Такими операциями являются присваивания выражений ссылочного типа,
      которые имеют в общем случае вид:
      \[lhs\_expr = rhs\_expr.\]
      Подобное выражение накладывает следующее ограничение на множества целей
      выражений:
      \[\Pts{lhs\_expr} \cupe \Pts{rhs\_expr},\]
      где $a \cupe b$~--- расширение множества $a$ множеством $b$.
      Для анализируемого метода получается набор ограничений на цели выражений,
      и цель алгоритма анализа определить для каждого выражения набор целей,
      удовлетворяющий ограничениям.

      В данной работе используется следующий алгоритм: имея некоторые
      начальные значения, множества целей выражений итеративно расширяются в
      соответствии с каждым отдельным ограничением до тех пор, пока все
      ограничения не будут удовлетворены. Доказательство сходимости и
      корректности данного алгоритма анализа приведено Андерсеном в
      работе~\cite{andersen}.

      \subsubsection{Основные анализируемые выражения}
        \label{section:pts_providers}

        Алгоритм работает со следующими выражениями ссылочного типа:
        \[ expr ::= v \mid v.f \mid \NEWi{k} \textrm{T}
               \mid \phi(v_1, \ldots, v_n)
               \mid {<}shared{>} \mid (\textrm{T})v, \]
        где $v$~--- локальная переменная, $f$~--- поле объекта, $T$~--- тип
        (выражения ${<}shared{>}$ и $(\textrm{T})v$ рассмотрены в
        разделах~\ref{sec:shared_introd} и~\ref{sec:cast_introd},
        соответственно). Более сложные выражения, например $(\textrm{T})v.f$ не
        рассматриваются, так как они могут быть легко преобразованы в более
        простые с помощью промежуточных переменных: $t_1 = v.f; t_2 =
        (\textrm{T})t_1$.

        \paragraph{Локальные переменные~---} это простейшие выражения
        ссылочного типа, которые хранят непосредственно множество абстрактных
        объектов, которое может быть прочитано или расширено другим множеством.
        Множество целей переменной $v$ обозначим как $\VPts{v}$, тогда доступ к
        множеству целей переменной есть
        \[ \Pts{v} = \VPts{v}, \]
        а условие \[\Pts{v} \cupe pts\] эквивалентно следующему:
        \[ \VPts{v} \cupe pts. \]

        \paragraph{Доступ к полям переменных} есть более сложная операция.
        Чтение и расширение множества целей этого выражения являются
        нетривиальными операциями.
        Нужно понимать, что множество целей поля переменной~--- это объединение
        множества целей полей объектов, на которые может указывать данная
        переменная:
        \[\Pts{v.f} = \bigcup\limits_{O \in \VPts{v}} \OFPts{O}{f},\]
        где $\OFPts{O}{f}$~--- множество целей поля абстрактного объекта,
        которое может быть прочитано или расширено.
        При расширении множества целей поля переменной необходимо аналогично
        расширить множество целей поля каждого объекта, на который может
        указывать переменная. Тогда условие \[\Pts{v.f} \cupe pts\]
        эквивалентно следующему:
        \[ \forall O \in \VPts{v}\quad \OFPts{O}{f} \cupe pts. \]

        Заметим, что часть выражений может находиться лишь в правой части
        присваивания, и следовательно, их множество целей не может быть
        расширено другим выражением. Такие выражения перечислены далее.

        \paragraph{Операция создания объекта} является выражением, множество
        целей которого всегда содержит один уникальный абстрактный объект для
        каждой отдельной операции создания объекта:
        \[\Pts{\NEWi{k} \textrm{T}} = \{O_k\}.\]
        Добавление уникального индекса каждому оператору \eng{new} и создание
        соответствующего абстрактного объекта может быть сделано
        предварительно.

        \paragraph{\phi-функция} является выражением, доступ к множеству целей
        которого возвращает объединение множества целей ее аргументов:
        \[\Pts{\phi(v_0, \ldots, v_n)} = \bigcup\limits_{i} \Pts{v_i}.\]

    \subsection{\texorpdfstring{Модель памяти языка \java}
                               {Модель памяти языка Java}}

      В этом разделе описана модель памяти, представленная в спецификации языка
      \java версии 5.0.
      Далее описаны особенности алгоритма анализа указателей для
      эффективного и корректного анализа программ, взаимодействующих через
      разделяемую память.

      Модели памяти различаются по тому, насколько сильные ограничения
      накладываются на последовательность исполнения операций чтения и
      записи.
      Модель памяти может быть очень строгой и требовать последовательного
      исполнения всех операций чтения и записи~\cite{lamport}.
      Такая модель сильно ограничивает набор используемых оптимизаций,
      так как многим из них требуется менять отдельные операции чтения и
      записи местами, а строгая модель памяти не позволит это сделать, даже
      если между операциями нет зависимости по управлению и данным.
      Слабая модель памяти может не определять какого-либо жесткого порядка
      исполнения операций. Основываясь на этой модели компилятор может
      довольно сильно преобразовывать программу с целью ее оптимизации,
      однако разработчику этой программы придется уделять очень много времени
      для написания корректной программы в рамках такой слабой модели памяти.

      Модель памяти, представленная в спецификации языка \java версии 5.0
      является компромиссом между возможностью проведения широкого класса
      оптимизаций и удобством разработки программ на языке \java. Подробное
      описание можно найти в спецификации JSR-133~\cite{jsr133}. Модель памяти
      является достаточно строгой и однозначно определяет, как будут
      исполняться корректно синхронизированные программы (программы, в которых
      отсутствуют конфликты доступа\footnote{
        Конфликт доступа \engdef{data-race} образуют две операции доступа к
        разделяемой памяти из разных потоков, если хотя бы одна из них~---
        запись, и эти операции не упорядочены в рамках модели памяти (подробнее
        см.~\cite[раздел~2.1]{manson_jmm}).
      } \engdef{data-race free}). Однако она является и достаточно слабой,
      позволяя проводить многие оптимизации.

      Рассмотрим семантику чтения и записи полей с учетом данной модели памяти
      (подробнее в~\cite{jsr133_cookbook}). \eng{Volatile} полями будем
      называть поля, которые объявлены с ключевым словом \eng{volatile}, что
      изменяет семантику доступа к ним.

      Сначала определим, какие операции доступа к полям объектов разрешено
      переставлять компилятору и/или процессору
      (см.~табл.~\ref{tabular:can_reorder}).
      Допустимо переставлять две операции чтения или записи обычных полей, если
      между ними нет зависимости по данным. Но не позволяется переставлять две
      операции чтения или записи \eng{volatile}\footnote{
        \eng{Volatile}~--- ключевое слово языка \java, которое может применено
        к полю, что изменяет семантику доступа к нему.
      } полей. Так же не позволяется
      переставлять две последовательные операции, где первая~--- чтение
      \eng{volatile} поля или где вторая~--- запись в \eng{volatile} поле.

      \begin{table}[!htb]
        \centering

        \def\yes{\multirow{2}{*}{}}
        \def\no{\multirow{2}{*}{Нет}}

        \begin{tabular}{ |c|c|c|c|c| }
          \cline{3-5}
          \multicolumn{2}{c|}{} & \multicolumn{3}{c|}{2-ая операция} \\
          \cline{3-5}
          \multicolumn{2}{c|}{} & Чтение/запись & Чтение              & Запись \\
          \multicolumn{2}{c|}{} & обычного поля & \eng{volatile} поля & \eng{volatile} поля \\
          \hline
          \multirow{6}{*}{\begin{sideways}1-ая операция\end{sideways}}
          & Чтение/запись       & \yes & \yes & \no \\
          & обычного поля       &      &      &     \\ \cline{2-5}
          & Чтение              & \no  & \no  & \no \\
          & \eng{volatile} поля &      &      &     \\ \cline{2-5}
          & Запись              & \yes & \no  & \no \\
          & \eng{volatile} поля &      &      &     \\ \hline
        \end{tabular}
        \caption{Возможность перестановки двух последовательных операций чтения
                 или записи поля объекта}
        \label{tabular:can_reorder}
      \end{table}

      Далее определим, какие значения могут возвращать операции чтения
      разделяемой памяти. Модель памяти гарантирует, что после записи значения
      в \eng{volatile} поле одним из потоков все последующие чтения этого поля
      вернут новое значение. Но подобное поведение не гарантируется при работе
      с обычными полями. Запись в обычное поле одним из потоков может быть не
      видна другим потокам при чтении этого поля. Это может происходить из-за
      наличия у каждого потока локальных копий обычных полей.  Однако модель
      памяти определяет, когда эти локальные копии обязаны быть
      синхронизированы с реальной разделяемой памятью: при записи в
      \eng{volatile} поле все локальные записи памяти должны быть отражены в
      разделяемой памяти, а при чтении \eng{volatile} поля все локальные данные
      должны быть заново прочитаны из разделяемой памяти.

      Операции языка \java для входа в блок синхронизации \engdef{synchronized
      block} и выхода из него влияют на возможность перестановки операций и
      синхронизированность локальной памяти с разделяемой так же, как чтение и
      запись \eng{volatile} полей, соответственно.

      Данные правила можно пояснить на примере~\ref{code:volatile_synch}.
      В первом потоке запись данных произойдет до установки флага готовности,
      так он является \eng{volatile}, и следовательно не может быть переставлен
      с предыдущей операцией. Также при установке флага готовности данные
      гарантированно будут записаны в разделяемую память.
      Во втором потоке после чтения \eng{volatile} флага данные будут прочитаны
      именно из разделяемой памяти, причем это произойдет после чтения флага,
      так как эти две операции не могут быть переставлены.
      Следовательно, если данные будут выставлены первым потоком, то именно
      они и будут прочитаны вторым потоком.
      \begin{algorithm}
        \caption{Синхронизация через \eng{volatile} переменную
          ($data$~--- обычное поле, $ready$~--- \eng{volatile} поле)}
        \label{code:volatile_synch}
        \begin{multicols}{2}
          \algorithmictitle{Поток 1}
          \begin{algorithmic}[1]
            \STATE $data$ = get\_data()
            \STATE $ready$ = \BOOLTRUE
          \end{algorithmic}
          \columnbreak
          \algorithmictitle{Поток 2}
          \begin{algorithmic}[1]
            \WHILE{ \textbf{not } $ready$ }
            \STATE \COMMENT{waiting}
            \ENDWHILE
            \STATE use\_data($data$)
          \end{algorithmic}
        \end{multicols}
      \end{algorithm}

      \subsubsection{Особенности анализа многопоточных программ}
        \label{sec:shared_introd}

        Для описания взаимодействия с разделяемой памятью введено специальное
        выражение ссылочного типа ${<}shared{>}$, которое представляет
        множество всех абстрактных объектов, разделяемых между потоками. Одной
        из его особенностей является то, что множество целей этого выражения
        изначально не пусто, а содержит в себе специальный объект
        $O_{global}$, соответствующий всем абстрактным объектам, созданным
        вне анализируемого метода (введение такого объекта соответствует
        консервативному предположению о том, что все объекты, созданные вне
        анализируемого метода, могут быть синонимами).

        Множество абстрактных объектов, разделяемых между потоками обозначим
        как $\Shared$. Соответственно чтение множества целей выражения
        ${<}shared{>}$ есть \[\Pts{{<}shared{>}} = \Shared.\]

        Если объект был присвоен в разделяемую память, то он должен попасть в
        множество $\Shared$. Также все объекты, на которые ссылаются поля
        разделяемого объекта, должны попасть в множество $\Shared$. Значит при
        добавлении объекта в множество $\Shared$, необходимо добавить в него и
        значения полей этого объекта. Тогда условие
        \[ \Pts{{<}shared{>}} \cupe pts \]
        может быть выражено следующим образом:
        \[ S_0 = \Shared \cup pts, \]
        \[ S_{i+1} = S_i \cup
           \bigcup_{\substack{O \in S_i\\ f \in fields(O)}} \OFPts{O}{f}, \]
        \[ \Shared = \text{неподвижная точка последовательности } \{S_i\}. \]
        Условие $\Pts{v.f} \cupe pts$ также может приводить к итеративному
        расширению множества $\Shared$ множеством $pts$, если в множестве
        $\VPts{v}$ есть хотя бы один разделяемый объект.

        Определим вспомогательное свойство анализируемого метода: присутствие
        операций, приводящих к повторному чтению полей объектов из разделяемой
        памяти (т.\,е. операций чтения \eng{volatile} поля и входа в блок
        синхронизации). Если такие операции присутствуют, то согласно модели
        памяти языка \java, поля разделяемых объектов обязаны быть прочитаны
        из разделяемой памяти после каждой такой операции. Так как мы
        используем нечувствительный к потоку управления анализ, можно считать,
        что поля разделяемых объектов должны читаться из разделяемой памяти при
        каждом доступе к ним. А это в свою очередь означает, что при чтении
        поля разделяемого объекта может быть получен любой из разделяемых
        объектов, так как другие потоки могли его туда записать.
        Для имитации такого поведения при доступе к множеству целей поля
        переменной множество целей дополнительно расширяется множеством
        разделяемых объектов:
        \[\Pts{v.f} = \Bigl(\bigcup\limits_{O \in \VPts{v}} \OFPts{O}{f} \Bigr)
                 \cup \Shared.\]

        Если операций, приводящих к повторному чтению полей объектов, нет,
        анализируемой программе разрешено хранить локальные копии полей
        объектов, а алгоритму, соответственно, нет необходимости расширять их
        множество целей всеми разделяемыми объектами.

    \subsection{Система типов языка}
      \label{section:type_system}

      В начале этого раздела описана строгая система типов на примере языка
      \java, затем представлены изменения в алгоритме с целью повышения его
      точности.

      В языке \java все типы делятся на примитивные и ссылочные.
      Примитивные типы можно не рассматривать в контексте анализа указателей,
      так как они не могут переносить информацию о целях указателей.
      Ссылочные типы~--- это классы, интерфейсы и массивы.
      Для любого выражения ссылочного типа $expr$ можно определить его
      формальный тип $\Type{expr}$ и для любого объекта $O$ тип $\Type{O}$.

      На множестве ссылочных типов можно определить отношение частичного
      порядка, соответствующее совместимости по присваиванию:
      $A \leq B$ тогда и только тогда, когда значение типа $B$ можно присвоить
      в выражение с формальным типом $A$~\cite{nastia_type_analysis}.
      Также можно ввести отношение несовместимости двух типов, выполняющееся,
      если не существует типа, совместимого по присваиванию с ними обоими:
      \begin{equation}\label{eq:incomp}
        A \incomp B
        \Leftrightarrow
        \lnot \exists C\colon A \leq C \land B \leq C.
      \end{equation}

      Согласно спецификации языка \java, во время исполнения программы
      выражение ссылочного типа может указывать только на те объекты, тип
      которых совместим по присваиванию с формальным типом этого выражения:
      \begin{gather}
        O \in \Pts{expr}
        \Rightarrow
        \Type{expr} \leq \Type{O}, \\
        \label{eq:strict_typing}
        \Type{expr} \not\leq \Type{O}
        \Rightarrow
        O \not\in \Pts{expr}.
      \end{gather}

      Отсюда получается, что два выражения, имеющие несовместимые типы, не
      могут указывать на один и тот же объект:
      \begin{align*}
        \quad& \Type{a} \incomp \Type{b}
        \xRightarrow{(\ref{eq:incomp})} \\ \xRightarrow{(\ref{eq:incomp})}
        \lnot \exists C \quad& \Type{a} \leq C \land \Type{b} \leq C
        \Rightarrow \\ \Rightarrow
        \lnot \exists O \quad& \Type{a} \leq \Type{O}
                         \land \Type{b} \leq \Type{O}
        \Rightarrow \\ \Rightarrow
        \forall O \quad& \Type{a} \not\leq \Type{O}
                    \lor \Type{b} \not\leq \Type{O}
        \xRightarrow{(\ref{eq:strict_typing})} \\ \xRightarrow{(\ref{eq:strict_typing})}
        \forall O \quad& O \not\in \Pts{a}
                    \lor O \not\in \Pts{b}
        \Rightarrow \\ \Rightarrow
        \lnot \exists O \quad& O \in \Pts{a}
                         \land O \in \Pts{b}.
      \end{align*}

      \subsubsection{Использование информации о типах}
        \label{sec:cast_introd}

        Рассмотрим, какой тип имеют абстрактные объекты. Абстрактные объекты,
        соответствующие операциям создания объектов, имеют точный тип,
        определенный этой операцией.
        Специальный объект $O_{global}$ имеет искусственный тип, такой, что
        этот объект совместим по присваиванию с любым другим ссылочным типом.

        Все выражения ссылочного типа имеют формальный тип. Причем все цели
        конкретного выражения должны быть совместимы по присваиванию с его
        формальным типом.
        Отсюда следует, что при расширении множества целей выражения
        достаточно расширять его лишь теми объектами, которые совместимы по
        присваиванию с формальным типом выражения.
        Введем операцию $\Filter{T}{pts}$, которая фильтрует множество
        абстрактных объектов, оставляя только совместимые по присваиванию с
        типом $T$:
        \[ \Filter{T}{pts} =
           \bigl\{ O \bigm| O \in pts \land T \leq \Type{O} \bigr\}. \]
        Тогда операция расширения множества целей выражения $lhs$ множеством
        целей выражения $rhs$ может быть записана следующим образом:
        \[ \Pts{lhs} \cupe \Filter{\Type{lhs}}{\Pts{rhs}}. \]

        Также информация о типах может быть использована при проверке, могут ли
        два выражения быть синонимами. В первую очередь нужно проверить,
        совместимы ли их типы: если нет, то они точно не могут содержать ссылку
        на один и тот же объект и быть синонимами.

        Со строгой типизацией языка также связана операция преобразования типа
        $a = (T)b$.
        При таком преобразовании, если значение переменной $b$ не совместимо
        по присваиванию с типом $T$, будет выброшено исключение во время
        исполнения, поэтому в рамках алгоритма анализа можно считать, что
        выражение $(T)b$ имеет формальный тип $T$ и может указывать только на
        объекты, совместимые по присваиванию с типом $T$:
        \[\Pts{(T)b} = \Filter{T}{\Pts{b}}.\]

    \subsection{\texorpdfstring{Операции языка \java}
                               {Операции языка Java}}
      \label{section:operations}

      В этом разделе представлен список операций языка \java, которые прямо или
      косвенно влияют на цели указателей, и их интерпретация в рамках
      выражений, с которыми работает разработанный алгоритм анализа.

      Сначала определим точно, что может быть указателем в языке \java и
      подобных ему.

      В отличие от C-подобных языков, где допустимы указатели на:
      \begin{itemize}
        \item объекты в куче,
        \item объекты на стеке,
        \item локальные и глобальные переменные произвольного типа,
        \item поля объектов,
        \item элементы массивов,
        \item функции;
      \end{itemize}
      в \java-подобных языках целью указателя может быть только объект,
      находящийся в куче. Также отсутствует адресная арифметика (операции
      взятия адреса, чтения и записи по адресу), за счет чего ссылка на объект
      может появиться только по цепочке присваиваний, начиная с создания этого
      объекта в куче.

      При проведении анализа указателей достаточно рассматривать лишь
      операции, приведенные в таблице~\ref{tabular:operations}.

      \begin{table}
        \centering

        \begin{tabular}{|l|p{0.65\textwidth}|}\hline
          \textbf{Операция} & \textbf{Описание}\\ \hline

          $a = b$
          & присваивание значения $b$ переменной $a$ \\ \hline

          $a = \NULL$
          & указание, что $a$ не указывает ни на один объект \\ \hline

          $a_0 = \phi(a_1, a_2, \ldots)$
          & \phi-функция, которая появляется в связи с переводом программы в
            SSA-форму \\ \hline

          $a = \NEW \textrm{T}$
          & создание нового объекта типа $\textrm{T}$ в куче \\ \hline

          $a = b.f$
          & чтение поля объекта, на который ссылается $b$ \\ \hline

          $b.f = a$
          & запись в поле объекта, на который ссылается $b$ \\ \hline

          $a = \textrm{T}.f$
          & чтение статического поля класса $\textrm{T}$ \\ \hline

          $\textrm{T}.f = a$
          & запись в статическое поле класса $\textrm{T}$ \\ \hline

          $a = b$[\ldots]
          & чтение элемента массива $b$ \\ \hline

          $b[\ldots] = a$
          & запись в элемент массива $b$ \\ \hline

          $a = (\textrm{T})b$
          & преобразование значения переменной $b$ к типу $\textrm{T}$ \\ \hline

          $a = \textrm{foo}(b, \ldots)$
          & вызов функции foo, возвращающей значение ссылочного типа \\ \hline

          $\textrm{foo}(b, \ldots)$
          & вызов функции foo, либо не возвращающей значение, либо возвращающей
            значение примитивного типа \\ \hline

          $\textrm{synchronized}(a) \{\ldots\}$
          & вход и выход в блок синхронизации $a$ \\ \hline
        \end{tabular}
        \caption{Операции языка \java, влияющие на цели указателей
                 ($a$, $b$, $c$~--- переменные или формальные параметры
                 ссылочного типа)}
        \label{tabular:operations}
      \end{table}

      Рассмотрим подробнее чтение и запись элементов массива. Зачастую
      алгоритм анализа не может определить реальных значений индексов
      элементов, по которым происходит доступ к элементам массива, так как их
      значения будут доступны лишь во время исполнения программы.
      По этой причине алгоритм анализа не может различить доступ к отдельным
      элементам массива без привлечения дополнительного анализа
      диапазонов~\cite[раздел~8.12]{muchnick}, который выходит за рамки данной
      работы.
      Соответственно будем интерпретировать доступ к любому элементу массива,
      как доступ к одному единственному элементу, что является корректным
      поведением с точки зрения анализа, хотя и понижает его точность.

      \subsubsection{\texorpdfstring{Интерпретация операций языка \java}
                                    {Интерпретация операций языка Java}}

        В этом разделе для всех операций языка \java, достаточных для
        проведения анализа, приведена интерпретация с использованием выражений,
        описанных в предыдущих разделах.
        \begin{itemize}
          \item Присваивание вида $a = \NULL$ никак не влияет на $\Pts{a}$.
          \item Чтение \eng{volatile} поля объекта или вход в
                блок синхронизации задает, что в анализируемом методе
                присутствует операция, приводящая к повторному чтению полей
                объектов.
          \item Доступ к статическим полям класса $T$ осуществляется через
                синтетическую переменную $klass\_T$, которая определяется с
                помощью присваивания $klass\_T = {<}shared{>}$.
          \item Доступ к формальным параметрам анализируемого метода
                осуществляется через синтетические переменные $param\_i$ с
                соответствующим формальным типом.
                Определяются они с помощью набора присваиваний вида
                $param\_i = {<}shared{>}$.
          \item Доступ к элементам массива $a[\ldots]$ превращается в доступ к
                единственному полю $elements$, синтетически добавляемому к
                каждому типу-массиву.
          \item Вызов функции с параметрами $p_0, p_1, \ldots, p_n$
                преобразуется в серию присваиваний вида ${<}shared{>} = p_i$ и
                задает, что в анализируемом методе присутствуют операции,
                приводящие к повторному чтению полей объектов. Это
                соответствует консервативному предположению, что вызываемая
                функция может исполнять совершенно произвольный код.
          \item Возврат значения из функции $lhs = \textrm{func}(\ldots)$
                интерпретируется как присваивание $lhs = {<}shared{>}$.
        \end{itemize}
        После такого преобразования все операции будут иметь вид $lhs = rhs$,
        где в левой и правой части стоит одно из выражений, описанных в
        предыдущих разделах.

  \section{Вспомогательное внутреннее представление}
    \label{section:analysis_aux_ir}

    Большинство оптимизаций, которым требуются результаты анализа указателей,
    работают с внутренним представлением программы в виде CFG (это верно для
    большинства современных оптимизирующих компиляторов, для
    \eng{Excelsior~RVM} в том числе). Соответственно, компонента для проведения
    анализа указателей должна использовать то же внутреннее представление.

    Однако для эффективного проведения какого-либо анализа нередко требуется
    введение вспомогательного внутреннего представления, которое сохраняет в
    себе лишь ту информацию о программе, которая ему необходима.
    В данной работе было решено использовать вспомогательное внутреннее
    представление для проведения анализа указателей и хранения его результатов.

    Далее будет описано построение объектно-ориентированной модели
    вспомогательного внутреннего представления.

    \subsection{Абстрактные объекты и их множества}

      В первую очередь, необходимо ввести структуру данных, соответствующую
      объекту, на который может указывать выражение ссылочного типа. Назовем
      такой тип данных абстрактным объектом (\eng{AbstractObject}). Так как
      любой объект анализируемой программы является экземпляром некоторого
      класса, структура данных \eng{AbstractObject} также будет иметь ссылку
      \eng{type} на класс данного объекта.

      Введем структуру данных, соответствующую множеству целей указателя
      (\eng{Points\-To\-Set}). Эта структура данных инкапсулирует
      множество абстрактных объектов, предоставляя операции для объединения двух
      таких множеств и проверки наличия абстрактных объектов, общих для двух
      множеств.

      Добавим, что у объектов в анализируемой программе присутствуют поля
      ссылочного типа, которые также имеют множество целей. Соответственно
      структура данных \eng{AbstractObject} хранит в себе
      ассоциативный массив, в котором каждому нестатическому полю класса объекта
      сопоставляется его множество целей (\eng{PointsToSet}).

      Отдельно необходимо ввести структуру данных, которая соответствует
      специальному объекту $O_{global}$. Такая структура данных~--- это
      \eng{Everything\-Abstract\-Object}, наследуемая от \eng{AbstractObject}.
      У нее есть две особенности:
      \begin{enumerate}
        \item Ссылка \eng{type} указывает на специальный тип \eng{Everything},
              совместимый по присваиванию с любым другим ссылочным типом.
        \item Ассоциативный массив с множеством целей полей является
              динамическим. Будучи изначально пустым, он может быть расширен
              по мере необходимости, за счет чего может хранить множество целей
              полей произвольных классов анализируемой программы.
      \end{enumerate}

    \subsection{Поставщики целей указателя}

      В рамках разработанного алгоритма анализа указателей все выражения
      ссылочного типа рассматриваются как сущности, которые имеют некоторое
      множество целей и формальный тип.
      Данная идея реализуется во внутреннем представлении посредством введения
      интерфейса, назовем его поставщиком целей указателя
      (\eng{PointsToSetProvider}).
      Интерфейс определяет методы для доступа непосредственно к множеству целей
      ($getPointsToSet$) и типу соответствующего выражения ($getType$).

      Все структуры данных внутреннего представления, соответствующие выражениям
      ссылочного типа анализируемой программы, реализуют интерфейс поставщика
      целей указателей.
      Локальной переменной в анализируемой программе соответствует структура
      данных \eng{Variable}, результату создания объекта~--- \eng{Allocation} и
      так далее.
      Все структуры данных хранят в себе тип соответствующего выражения и набор
      целей, который может быть изменяемым набором, например, у локальной
      переменной, или вычислимым из других наборов, например, у \phi-функции
      (подробнее про правила вычисления наборов целей выражений, использованных
      в алгоритме анализа, в разделе~\ref{section:pts_providers}).

    \subsection{Набор присваиваний}

      В разделе~\ref{section:algorithm_basis} уже говорилось, что разработанный
      алгоритм работает с анализируемой программой, как с набором присваиваний,
      в которых в левой и правой части стоят выражения ссылочного типа. Во
      внутреннем представлении эта идея реализуется посредством хранения
      массива присваиваний (\eng{Assignment}), которые содержат в себе ссылки
      на два поставщика целей указателей, соответствующих выражениям в левой и
      правой части присваивания.

    \subsection{Использование разработанного представления}

      В примере~\ref{code:aux_ir} показан фрагмент \java программы и
      соответствующее вспомогательное внутреннее представление (выраженное в
      псевдокоде).
      Можно увидеть, как именно операции присваивания языка \java преобразуются
      в структуры данных, используемые в данной работе.

      \begin{algorithm}
        \caption{Вспомогательное внутреннее представление}
        \label{code:aux_ir}
        \begin{multicols}{2}
          \algorithmictitle{\java код}
          \begin{algorithmic}
            \STATE $\textbf{class }\textmd{A }%
                    \textbf{extends }\textmd{Object }\{$
            \STATE $\textmd{\quad Object }f;$
            \STATE $\}$
            \STATE $\ldots$
            \STATE $\{$
            \STATE $\textmd{\quad Object }x = \textbf{new }\textmd{A}();$
            \STATE $\textmd{\quad A }y = (\textmd{A})x;$
            \STATE $\textmd{\quad}y.f = \textbf{new }\textmd{Object}();$
            \STATE $\}$
          \end{algorithmic}
          \columnbreak
          \algorithmictitle{Его представление}
          \begin{algorithmic}
            \STATE $vx = \textmd{Var}\{\textmd{var}: \textmd{x},%
                              \textmd{type}: \textbf{Object}\}$
            \STATE $vy = \textmd{Var}\{\textmd{var}: \textmd{y},%
                              \textmd{type}: \textbf{A}\}$
            \STATE $assignments = [$
            \STATE $\textmd{\ }\{ \textmd{lhs}: vx,$
            \STATE $\textmd{\ \, rhs}: \textmd{Alloc}\{\textmd{type}: \textbf{A}\}\}$
            \STATE $\textmd{\ }\{ \textmd{lhs}: vy,$
            \STATE $\textmd{\ \, rhs}: \textmd{Cast}\{\textmd{target}: \textbf{A}, \textmd{var}: vx\}\}$
            \STATE $\textmd{\ }\{ \textmd{lhs}: \textmd{FieldAcc}\{\textmd{var}: vy, \textmd{field}: \textbf{f}\},$
            \STATE $\textmd{\ \, rhs}: \textmd{Alloc}\{\textmd{type}: \textbf{Object}\}\}$
            \STATE $]$
          \end{algorithmic}
        \end{multicols}
      \end{algorithm}

      Как можно заметить, при введении такого вспомогательного внутреннего
      представления, становится удобно проводить анализ указателей.
      Все операции, достаточные для проведения анализа, представляют из себя
      присваивание выражения, стоящего справа, выражению, стоящему слева.
      Причем этим выражениям анализируемой программы соответствуют структуры
      данных, реализующие интерфейс поставщика целей указателя. Это позволяет
      проводить анализ указателей, абстрагируясь от реального вида выражений,
      работая лишь с их типами и множествами целей.

      Также, имея такое вспомогательное внутреннее представление, можно легко
      определять, являются ли два выражения синонимами: достаточно получить
      экземпляры структур данных, соответствующие этим выражениями, проверить
      совместимость их типов и наличие общих абстрактных объектов в их
      множествах целей.

  \section{Реализация}

    Изначально был реализован тестовый стенд, изолированное окружение для
    проведения экспериментов. С его помощью можно проверять работу
    разных алгоритмов анализа указателей на характерных примерах, сравнивать их
    характеристики. Изолированность позволяет быстро разработать такую систему
    и легко вносить в нее изменения, так как не требуется интеграция с
    существующими интерфейсами оптимизирующего компилятора.

    Затем уже алгоритм анализа был реализован в рамках статического
    оптимизирующего \java компилятора.

    \subsection{Реализация тестового стенда}

      Реализована система, являющаяся простой моделью компилятора. Она включает
      в себя парсер простого \java-подобного языка, структуру для хранения
      внутреннего представления и компоненту, выполняющую анализ указателей.
      Также присутствуют методы просмотра разнообразной статистики: множества
      целей всех указателей, присутствующих в программе, точности результатов,
      времени работы алгоритма.

      Система принимает на входе программу в специальном формате через
      стандартный поток ввода. В начале программы идут определения классов
      с возможностью указания класса-предка и определения полей. Затем задается
      тело метода, для которого и будет проводится анализ указателей.
      Тело метода задается в SSA-форме и состоит из набора операций,
      достаточных для проведения анализа указателей (подробнее в
      разделе~\ref{section:operations}).

      Парсер на выходе получает AST (\eng{Abstract Syntax Tree}), из которого
      инициализируется иерархия классов и внутреннее представление
      единственного метода, которое передается в анализатор для проведения
      анализа указателей. В результате проведения анализа указателей
      предоставляются результаты в виде наборов целей указателей и другая
      статистика работы алгоритма.

      Система реализована на языке \eng{Ruby}, так как он позволяет очень
      быстро создать работающее приложение, для которого скорость работы не
      является критической характеристикой. Парсер осуществляет разбор входной
      программы с использованием регулярных выражений, что также является
      простым и быстрым в исполнении решением. Внутреннее представление метода
      реализовано в соответствии с разделом~\ref{section:analysis_aux_ir},
      при его инициализации дополнительно проверяется корректность всех
      операций.

      Функционал парсера и инициализация внутреннего представления
      имеют набор модульных тестов \engdef{unit test}. Разные варианты
      алгоритма анализа указателей также имеют модульные тесты для тестирования
      особенностей конкретного алгоритма.

    \subsection{Реализация в рамках компилятора}

      Разработанный алгоритм анализа был реализован в оптимизирующем
      компиляторе в виде отдельной компоненты на языке \eng{Oberon} 2.

      Работа компоненты разбита на два этапа: инициализация и предоставление
      результатов. Так как пользователю чаще всего необходимо проведение
      анализа синонимов для нескольких пар выражений одного метода, такое
      разбиение является естественным: при таком подходе инициализация
      внутреннего представления и анализ указателей будут проведены один раз
      для всего метода, а затем может следовать сколь угодно много запросов о
      синонимичности выражений (см.~рис.~\ref{fig:impl_arch}).

      \begin{myfigure}%
        {Работа компоненты, выполняющей анализ синонимов}%
        {fig:impl_arch}

        \tikzstyle{init} = [rectangle, draw, thin, fill=green!20,
                            minimum height=2em, rounded corners=3mm ]

        \tikzstyle{ask} =  [rectangle, draw, thin, fill=blue!10,
                            minimum height=2em, rounded corners=3mm ]

        \begin{tikzpicture}[auto,>=latex', thick]
          \path[->]
                    node[init]  (i1)                     {Инициализация}
                    node[ask]   (a2) [right=1cm   of i1] {$x$ и $y$?}
                    node[ask]   (a3) [right=1cm   of a2] {$u$ и $v$?}
                    node[ask]   (a4) [right=1cm   of a3] {$a$ и $b$?}
                    node[init]  (i5) [below=0.5cm of i1] {Инициализация}
                    node[ask]   (a6) [below=0.5cm of a2] {$x$ и $v$?}
                    node[ask]   (a7) [below=0.5cm of a3] {$u$ и $y$?}
                    node[] (f1) [right=0.25cm of a4] {}
                    node[] (f2) [left=0.25cm of i5]  {}
                    (i1) edge (a2)
                    (a2) edge (a3)
                    (a3) edge (a4)
                    (a4) edge[-] (f1)
                    (f2) edge (i5)
                    (i5) edge (a6)
                    (a6) edge (a7)
                    ;
          \draw[-] (f1.west) -- ++(0,-0.75) -| (f2.east);
        \end{tikzpicture}
      \end{myfigure}

      Для инициализации компоненты требуется внутреннее представление
      анализируемого метода программы в виде CFG. На его основе строится
      вспомогательное внутреннее представление в соответствии с
      разделом~\ref{section:analysis_aux_ir}. Затем проводится анализ
      указателей для всего метода программы (описание алгоритма приведено в
      разделе~\ref{section:algorithm}) и его результаты сохраняются во
      вспомогательном внутреннем представлении.

      После такой инициализации компонента может предоставлять информацию о
      синонимичности пар выражений ссылочного типа. Для этого необходимо
      определить элементы вспомогательного внутреннего представления,
      соответствующие данным выражениям, и проверить их синонимичность.
      Данная процедура может быть повторена многократно для
      различных пар выражений, если внутреннее представление данного метода при
      этом не изменялось. Если же по каким-либо причинам внутреннее
      представление метода было преобразовано, необходимо заново проводить
      инициализацию всей компоненты анализа.

  \section{Практические результаты}

    Представленный алгоритм анализа указателей был реализован в рамках
    статического \java компилятора \eng{Excelsior~RVM} и протестирован на
    стандартных тестах \java программ.

    Тестирование проходило следующим образом. Каждая программа, входящая в
    тестовый набор, компилируется статическим компилятором, и для каждого
    метода этой программы проводится анализ указателей с помощью разработанного
    алгоритма.
    После проведения анализа вычисляется мера точности результатов и
    предоставляется информация о времени работы и потреблении памяти
    алгоритмом.

    \subsection{Входные данные}

      В рамках тестирования использовались следующие приложения:
      \begin{enumerate}
        \item \eng{SPEC~JVM98}~\cite{spec_jvm98}~--- это набор, состоящий из 8
              тестов, 5 из которых являются реальными приложениями. Общее
              количество методов в этом тесте: \num{3701}.
        \item \eng{SPECjvm2008}~\cite{spec_jvm2008}~--- это набор, состоящий из
              нескольких реальных приложений и некоторого количества
              искусственных бенчмарков, приложений для измерения
              производительности.
              Общее количество методов в данном наборе: \num{37931}.
        \item \eng{Eclipse~IDE}~\cite{eclipse} (версия 3.6)~--- среда
              разработки кроссплатформенных приложений.
              Общее количество методов в приложении: \num{263802}.
      \end{enumerate}
      Данные о размерах методов, скорости работы алгоритма и потреблении памяти
      представлены для приложения \eng{Eclipse~IDE}.

      Для каждого анализируемого метода можно получить следующую информацию:
      \begin{itemize}
        \item количество операций присваивания выражений ссылочного типа;
        \item количество операций создания новых объектов;
        \item количество переменных ссылочного типа.
      \end{itemize}

      Определим, с какими входными данными приходится работать алгоритму
      анализа. Как видно из графиков, представленных на
      рис.~\ref{plot:nassig_distribution} и~\ref{plot:nobj_distribution},
      абсолютное большинство методов имеет меньше \num{20} присваиваний и в
      этих методах находится меньше \num{6} операций создания новых объектов.
      Можно заметить, что предположение о том, что большинство методов является
      небольшими по размеру, использованное при выборе типа алгоритма анализа,
      оправдало себя на практике.

      \begin{myplot}%
        {Распределение количества методов от числа присваиваний в них}%
        {plot:nassig_distribution}
        \inputplot{plots/nassig_distribution.tex}
      \end{myplot}

      \begin{myplot}%
        {Распределение количества методов от числа операций создания новых
        объектов в них}%
        {plot:nobj_distribution}
        \inputplot{plots/nobj_distribution.tex}
      \end{myplot}

    \subsection{Скорость работы}

      Как было сказано в разделе~\ref{section:algorithm}, алгоритм осуществляет
      многочисленные проходы по присваиваниям метода до тех пор, пока
      множества целей всех выражений не стабилизируются. В ходе тестов было
      получено, что число таких проходов обычно невелико: в нашем случае оно не
      превышает \num{10} и не увеличивается при увеличении размеров метода
      (см.~рис.~\ref{plot:iter_count}).

      \begin{myplot}%
        {Зависимость числа проходов алгоритма анализа от размера метода
        (радиус кругов пропорционален количеству методов)}%
        {plot:iter_count}
        \inputplot{plots/iter_count.tex}
      \end{myplot}

      \begin{myplot}%
        {Зависимость числа операций объединения множеств от размера метода}%
        {plot:merge_ops}
        \inputplot{plots/merge_ops.tex}
      \end{myplot}

      \begin{myplot}%
        {Зависимость времени, потраченного на объединение множеств, от размера
        метода}%
        {plot:simple_ops}
        \inputplot{plots/simple_ops.tex}
      \end{myplot}

      Больший интерес представляет количество операций объединения множеств и
      суммарное время, затраченное на эти операции\footnote{
        Объединение двух множеств проводится за время, пропорциональное их
        размеру.
      }. Их зависимость от размеров программы представлена на
      рис.~\ref{plot:merge_ops},~\ref{plot:simple_ops}. Видно, что количество
      операций объединения множеств линейно зависит от размеров метода, а
      время, затраченное на эти операции, близко к квадратичному.

      Получается, что на практике алгоритм работает за время, пропорциональное
      квадрату размера метода. Это согласуется с теоретически расчитанной
      временной сложностью алгоритма, которая есть $O(N^3)$ в худшем случае,
      причем видно, что на практике <<худший случай>> не достигается.

    \subsection{Потребление памяти}

      \begin{myplot}%
        {Зависимость объема множеств целей от размера метода}%
        {plot:mem_used}
        \inputplot{plots/mem_used.tex}
      \end{myplot}

      Для хранения множеств целей указателей алгоритм использует значительные
      объемы памяти. На рис.~\ref{plot:mem_used} представлена зависимость
      этого объема от размеров программы. Объем потребляемой памяти имеет
      существенный разброс при анализе больших методов, но может быть
      оценен сверху величиной, пропорциональной квадрату размера метода.
      Такой результат является приемлимым для использования в рамках
      оптимизирующего компилятора.

    \subsection{Сравнение точности}

      Нужно понимать, что сравнивать результат работы алгоритма с <<реальными>>
      результатами невозможно, так как получение таких результатов потребует
      исполнения программы на всех возможных входных данных. Поэтому
      сравнивалась относительная точность разных алгоритмов анализа.
      Для сравнения с основным алгоритмом были использованы следующие его
      вариации:
      \begin{itemize}
        \item алгоритм, не учитывающий информацию о типах языка (на графиках
              обозначен как <<\eng{w/o types}>>);
        \item алгоритм, не учитывающий потоки данных в программе (учитывающий
              только информацию о типах) (на графиках обозначен как <<\eng{w/o
              data flow}>>);
        \item алгоритм \eng{equality-based} типа (на графиках обозначен как
              <<\eng{equality-based}>>).
      \end{itemize}
      Работа этих алгоритмов были сымитирована основным алгоритмом, что не дает
      истинных результатов о скорости их работы и потреблении памяти, однако
      предоставляет достоверную информацию об их точности.

      Сравнение четырех алгоритмов анализа проводилось на всех трех тестовых
      приложениях.
      В качестве меры точности результатов анализа использовалось усредненное
      количество синонимов для переменных ссылочного типа, поделенное на
      общее количество переменных.
      Чем ниже это число, тем более точные результаты дает алгоритм анализа.
      Результаты представлены в виде двух типов графиков.
      На первом представлена зависимость количества методов от значения меры
      точности, которая получилась при анализе этих методов
      (см.~рис.~\ref{plot:specjvm_all_aliases_distribution},~\ref{plot:specjvm2008_all_aliases_distribution}
              и~\ref{plot:eclipse_all_aliases_distribution}).
      Второй график является кумулятивной версией первого
      (см.~рис.~\ref{plot:specjvm_all_aliases_distribution_cumulative},~\ref{plot:specjvm2008_all_aliases_distribution_cumulative}
              и~\ref{plot:eclipse_all_aliases_distribution_cumulative}),
      и на нем удобнее сравнивать точность различных алгоритмов:
      среди двух алгоритмов анализа более точным является тот, у которого
      соответствующая кривая проходит выше.

      \begin{myplot}%
        {Зависимость количества методов от значения меры точности для \eng{SPEC~JVM98}}%
        {plot:specjvm_all_aliases_distribution}
        \inputplot{plots/specjvm_all_aliases_distribution.tex}
      \end{myplot}

      \begin{myplot}%
        {Распределение методов от значения меры точности для \eng{SPEC~JVM98}}%
        {plot:specjvm_all_aliases_distribution_cumulative}
        \inputplot{plots/specjvm_all_aliases_distribution_cumulative.tex}
      \end{myplot}

      \begin{myplot}%
        {Зависимость количества методов от значения меры точности для \eng{SPECjvm2008}}%
        {plot:specjvm2008_all_aliases_distribution}
        \inputplot{plots/specjvm2008_all_aliases_distribution.tex}
      \end{myplot}

      \begin{myplot}%
        {Распределение методов от значения меры точности для \eng{SPECjvm2008}}%
        {plot:specjvm2008_all_aliases_distribution_cumulative}
        \inputplot{plots/specjvm2008_all_aliases_distribution_cumulative.tex}
      \end{myplot}

      \begin{myplot}%
        {Зависимость количества методов от значения меры точности для \eng{Eclipse~IDE}}%
        {plot:eclipse_all_aliases_distribution}
        \inputplot{plots/eclipse_all_aliases_distribution.tex}
      \end{myplot}

      \begin{myplot}%
        {Распределение методов от значения меры точности для \eng{Eclipse~IDE}}%
        {plot:eclipse_all_aliases_distribution_cumulative}
        \inputplot{plots/eclipse_all_aliases_distribution_cumulative.tex}
      \end{myplot}

      Интересно наблюдать за разностью в точности на разных тестовых
      приложениях. Видно, что в наборе \eng{SPEC~JVM98} алгоритм анализа, не
      использующий информацию о потоках данных, дает существенно худшие
      результаты по сравнению с основным алгоритмом. Однако алгоритм анализа,
      не использующий информацию о типах, обладает еще меньшей точностью. В
      наборе \eng{SPECjvm2008} ситуация отличается: алгоритмы, не использующие
      информацию о типах и о потоках данных, имеют близкую точность. Наконец,
      в приложении \eng{Eclipse~IDE} ситуация обратна набору \eng{SPEC~JVM98}:
      алгоритм анализа, не использующий информацию о типах, обладает заметно
      лучшей точностью по сравнению с алгоритмом, не использующим информацию о
      потоках данных.
      Эти измерения демонстрируют, что использование информации о типах
      и о потоках данных является необходимым для получения удовлетворительной
      точности, хотя использование такой информации вносит разный вклад в
      итоговую точность алгоритма на разных приложениях.

      Также было проведено сравнение основного алгоритма \eng{subset-based}
      типа и его модификации, являющейся алгоритмом \eng{equality-based}. На
      всех тестовых приложениях точность второго алгоритма оказалсь хуже, но не
      так сильно, как в случае алгоритмов, не использующих информацию о потоках
      данных или типах. Эти результаты подтверждают, что выбор в пользу
      алгоритма \eng{subset-based} типа был сделан правильно, и он
      действительно обладает большей точностью. Однако результаты не
      согласуется с предположением о том, что точность алгоритмов
      \eng{subset-based} типа значительно выше точности алгоритмов
      \eng{equality-based} типа. Это может быть объяснено тем, что при
      тестировании использовалась лишь имитация алгоритма \eng{equality-based}
      типа с помощью \eng{subset-based} алгоритма, что дает некоторый выигрыш
      в точности из-за особенностей реализации.

      В целом можно видеть, что использование определенных свойств языка при
      анализе дает существенный прирост точности конечного алгоритма. Причем
      вклад от использования отдельных свойств может меняться в зависимости от
      анализируемого приложения, поэтому невозможно выделить какое-либо
      <<главное>> свойство языка, которое дает наибольший прирост точности.
      Важно использование всех доступных свойств анализируемого языка, которые,
      дополняя друг друга, дают наилучший результат.


  \sectionwithoutnumber{Заключение}

    Целью данной работы являлась разработка внутрипроцедурного алгоритма
    анализа указателей, адаптированного для анализа многопточных \java программ.
    Данная цель была успешно достигнута и в ходе работы было сделано следующее:
    \begin{itemize}
      \item Проведен анализ существующих алгоритмов анализа указателей и
            синонимов, выделены их основные отличительные характеристики.
      \item Реализован тестовый стенд для изучения свойств разных алгоритмов
            анализа.
      \item Изучена спецификация языка \java и выявлены свойства, влияющие на
            анализ указателей.
      \item Разработан внутрипроцедурный алгоритм анализа указателей,
            учитывающий особенности языка \java и адаптированный для анализа
            многопоточных программ в соответствии с моделью памяти языка \java.
      \item Разработано внутреннее представление, которое позволяет эффективно
            проводить анализ указателей и хранить его результаты.
      \item Реализована компонента, интегрированная в статический \java
            компилятор \eng{Excelsior~RVM}, выполняющая анализ синонимов.
      \item Проведено измерение времени работы и потребления памяти
            разработанного алгоритма анализа. Также проведено сравнение
            точности результатов с другими алгоритмами.
    \end{itemize}

    В дальнейшем планируется реализация данного алгоритма анализа указателей и
    синонимов в промышленном статическом \java компиляторе \eng{Excelsior~JET}.
    Также планируется адаптация представленного алгоритма для межпроцедурного
    анализа.

  \newpage
  \bibliography{../../biblio}

\end{document}


\documentclass[a4,14pt,titlepage]{extarticle}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{color}
\usepackage{algorithmic}

\title{
  Анализ указателей и синонимов для многопоточных программ
}
\author{
  Владимир Парфиненко
}

% поля и размер текста
\textwidth=17cm
\oddsidemargin=-8pt
\topmargin=0pt
\headheight=0pt
\headsep=0pt
\textheight=23cm
\linespread{1.3}

\bibliographystyle{gost780u}

%\newcommand{\remark}[1]{}
\newcommand{\remark}[1]{\textcolor{blue}{#1}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\newcommand{\eng}[1]{{\English#1}}

\begin{document}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %           Титульная страница
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \thispagestyle{empty}
  \begin {center}
    Министерство образования и науки

    Российской Федерации

    Федеральное агентство по образованию

    \vspace{0.3cm}

    Новосибирский государственный университет

    \vspace{0.3cm}

    Физический факультет

    Кафедра Автоматизации Физико-Технических Исследований

    \vspace {40mm}

    %Выпускная квалификационная работа бакалавра
    Октябрьский отчет

    \vspace {10mm}

    Парфиненко Владимир Владимирович

    \vspace {5mm}

    \textbf{АНАЛИЗ УКАЗАТЕЛЕЙ И СИНОНИМОВ\\ ДЛЯ МНОГОПОТОЧНЫХ ПРОГРАММ}

    \vspace {20mm}

    {\raggedleft

    Научный руководитель

    м.\,н.\,с.~ИСИ~СО~РАН, Павлов\,П.\,Е.

    \vspace {50mm}

    Новосибирск 2010}
  \end {center}


  \tableofcontents

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                  Введение
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \section{Введение}

    Средства оптимизации программ нужны для получения высокой
    скорости исполнения программ или улучшения других характеристик программы.

    Под оптимизацией программ понимается преобразование программы в
    семантически эквивалентную, но более эффективную относительно некоторого
    заданного критерия.
    Преобразование программы $A$ в программу $B$ эквивалентно (или корректно),
    если из того, что программа $A$ выполнима на некотором наборе данных,
    следует, что и $B$ также выполнима на этом наборе и дает тот же результат,
    что и $A$.
    В общем случае задача проверки эквивалентности двух программ неразрешима,
    и не существует алгоритма, который по данной программе находил бы
    эквивалентную ей и оптимальную относительно заданного критерия
    \cite{kasjanov_translators}.

    Тем не менее существует набор известных оптимизирующих преобразований,
    таких, что корректность каждого из них гарантирует корректность их
    последовательного применения.
    И чтобы конкретное преобразование данной программы было корректным,
    необходимо выполнение некоторых условий. Например, чтобы иметь
    возможность убрать генерацию некоторой части программы, нужно быть
    увереным, что управление никогда не попадет в эту часть программы.
    Для получения подобной информации используют результаты статического
    анализа. Анализируя код программы, деляются выводы о тех или иных свойствах
    программы, необходимых для корректности преобразования.

    Статический анализ применяется не только для проверки
    корректности преобразований, но и в инструментах статического анализа
    кода программ, которые могут находить потенциальные ошибки и определять
    другие свойства программы без ее непосредственного исполнения.

    Существует множество видов статического анализа, и одним из них
    является анализ указателей и синонимов.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%        Описание предметной области
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \section{Описание предметной области}

    Анализ указателей~--- это один из видов статического анализа, который
    позволяет определить на какие объекты в памяти могут указывать выражения
    ссылочного типа в программе. Анализ синонимов похож на анализ указателей,
    его целью является определение, могут ли два разных выражения ссылаться
    на одно и то же место в памяти (такие выражения называют синонимами).

    Существует множество алгоритмов анализа указателей и синонимов,
    одним из них является алгоритм анализа, основанный на типах
    (\eng{Type-Based Alias Analysis}) \cite{diwan_tbaa},
    применимый для языков со строгой типизацией.
    Наличие строгой типизации гарантирует, что ссылочная переменная формального
    типа $T$ может ссылаться либо на объект типа $T$, либо на объект типа $S$,
    где $S$ является наследником типа $T$.
    Простейшая реализация алгоритма основанного на типах считает, что
    любая ссылочная переменная формального типа $T$ может указывать на любые
    объекты типа $T$ или его наследников. Такой алгоритм работает очень быстро,
    но обладает сравнительно низкой точностью.

    Более точные алгоритмы анализа обращают внимание не только на типы
    переменных, но и на потоки данных в программе. Например, если мы в
    переменную делали только одно присваивание нового объекта типа $T$
    выделенного в куче, то мы можем гарантировать, что эта переменная может
    указывать только на этот объект.  С присваиванием одной переменной в другую
    ситуация сложнее.
    Рассмотрим следующий пример:
    \begin{algorithmic}[1]
    \STATE $b$ = new T()
    \STATE $c$ = new T()
    \STATE $a$ = $b$
    \STATE $a$ = $c$
    \end{algorithmic}
    Для удобства, множество объектов, на которые может указывать указатель $p$
    (или переменная ссылочного типа), обозначим как $Pts(p)$
    (англ. \eng{Points-to set}).
    Учитывая строки 1 и 2, для переменных $b$ и $c$ мы можем точно определить
    множество объектов, на которые они указывают,
    \[Pts(b) = \{O_1\}, Pts(c) = \{O_2\},\] где $O_1$ и $O_2$ уникальные
    объекты в куче. То есть мы уже учли поток данных от оператора new,
    вернувшего новый объект, в переменную.

    Интерпретировать присваивание $a = b$ можно двумя способами,
    и алгоритмы анализа разбиваются на два типа по этому признаку:
    \begin{itemize}
      \item \eng{subset-based} алгоритмы накладывают ограничение, что
            $Pts(b) \subset Pts(a)$,
      \item \eng{equality-based} алгоритмы накладывают ограничение, что
            $Pts(b) = Pts(a)$.
    \end{itemize}
    Первый тип алгоритмов более точен, в то время как второй быстрее
    \cite{steensgaard}. Возвращаясь к нашему примеры, \eng{subset-based}
    алгоритм получит, что
    \[Pts(a) = \{O_1, O_2\}, Pts(b) = \{O_1\}, Pts(c) = \{O_2\},\]
    а \eng{equality-based}
    \[Pts(a) = Pts(b) = Pts(c) = \{O_1, O_2\}.\]

    Особое внимание следует обратить на то, как алгоритм анализа обрабатывает
    вызовы функций. Рассмотрим следующий пример:
    \begin{algorithmic}[1]
    \STATE function foo($x$, $y$) \{ return $x$ \}
    \STATE $b$ = new T()
    \STATE $c$ = new T()
    \STATE $a$ = func($b$, $c$)
    \end{algorithmic}
    Наша задача понять, чему равно $Pts(a)$.
    Алгоритмы анализа можно разделить на две категории, в зависимости от того,
    как они обрабатывают вызовы функций:
    \begin{itemize}
      \item межпроцедурные алгоритмы анализа могут сначал проанализировать
            тело вызываемой функции, и затем учесть результат при обработке
            вызова,
      \item внутрипроцедурные алгоритмы рассматривают вызов функции в наиболее
            консервативном предположении: может быть возвращен либо один из
            параметров, либо любой глобальный объект, либо новый объект.
    \end{itemize}
    Понятно, что первый тип алгоритмов дает более точные результаты,
    а второй потребляет меньше памяти и работает быстрее [\todo{ссылка?}].
    В нашем примере межпроцедурный алгоритм анализа, может понять, что
    для функции foo выполнено следующее условие на возвращаемое значение
    \[Pts(retval) = Pts(x),\]
    и тогда сделать вывод, что \[Pts(a) = Pts(b) = \{O_1\}.\]
    А внутрипроцедурный алгоритм анализа обязан сделать консервативное
    предположение \[Pts(a) = Pts(b) \cup Pts(c) = \{O_1, O_2\}.\]


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %             Постановка задачи
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \section{Постановка задачи}
    \todo{поставить}

    Целью данной работы является изучение существующих алгоритмов анализа
    указателей, последующее проектирование алгоритма и
    внутренного представления для использования в оптимизирующем
    статическом компиляторе Java программ
    \eng{Excelsior Research Virtual Machine (Excelsior~RVM)}
    с учетом двух следующих требований.

    Во-первых,
    проектирование алгоритма анализа программ исполняемых в управляемых средах
    (таких как \eng{Java Virtual Machine (JVM)} и платформа
    \eng{Microsoft .NET}) накладывает дополнительные ограничения на алгоритм в
    связи с наличием строгой типизации и размещением большинства объектов в
    куче.

    Во-вторых, необходима адаптация алгоритма анализа
    для применения к многопоточным программам,
    которые в данный момент получают широкое распространение
    из-за появления многоядерных процессоров практически
    на каждом персональном компьютере.

    Для решения поставленной в работе задачи необходимо спроектировать алгоритм
    анализа и внутреннее представление и реализовать их в виде компоненты
    для оптимизирующего статического компилятора Java программ.


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %             Список литературы
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \addcontentsline{toc}{section}{Список литературы}
  \bibliography{../../biblio}

\end{document}


\documentclass[12pt]{article}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[usenames,dvipsnames]{color}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[pdftex]{graphicx}
\usepackage{multicol}

% поля и размер текста
\textwidth=17cm
\oddsidemargin=-8pt
\topmargin=0pt
\headheight=0pt
\headsep=0pt
\textheight=23cm
\linespread{1.3}

\title{
  «Анализ указателей и синонимов для многопоточных программ»\\
  Презентация
}
\author{
  Владимир Парфиненко
}

%\newcommand{\remark}[1]{}
\newcommand{\remark}[1]{\textcolor{Green}{#1}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\todocite}{[\todo{cite}]}

\newcommand{\slide}[1]{\textcolor{Blue}{[Слайд: #1]}}

\newcommand{\eng}[1]{{\English#1}}

\begin{document}
  {\Large Текст презентации к предзащите, 5 минут}
  \vspace{5mm}

  \paragraph{Кто я.}
  \slide{титульный с названием и фамилиями моей и научрука}
  Здравствуйте, меня зовут Владимир Парфиненко, я являюсь студентом 4-го
  курса Новосибирского Государственного Университета, и тема моей работы
  <<Анализ указателей и синонимов для многопоточных программ>>.

  \paragraph{Содержание.} \todo{На защите огласить план всей презентации}

  \paragraph{Место анализа.}
  Я начну с краткого введения в предметную область моей работы: статический
  анализ.
  \slide{многообразие статических анализаторов и оптимизирующих компиляторов}
  Этот вид анализа применяется в оптимизирующих компиляторах и в инструментах
  статического анализа кода.  Остановимся подробнее на оптимизирующих
  компиляторах.
  Оптимизация программы~--- это ее преобразование с целью улучшения какой-либо
  характеристики (скорость исполнения, потребление памяти и так далее).
  Рассмотрим простой пример оптимизации:
  \slide{тривиальный вынос инварианта из цикла}
  В данном примере видно, что выражение $a[i] = y.h$ можно вынести из цикла,
  что ускорит исполнение программы. Но нужно помнить, что это преобразование
  должно быть корректным: оно должно сохранять семантику программу.
  \slide{неудачный вынос если переменные синонимы}
  Если вместо поля $h$ будет читаться поле $f$, то подобный вынос может
  изменить семантику программы: если переменные $x$ и $y$ будут ссылаться на
  один объект, то значение $y.f$ будет разным на каждой итерации цикла.
  Значит, если мы хотим провести эту оптимизацию необходимо нечто, что
  сможет ответить на вопрос, могут ли две переменные ссылаться на один объект.
  \slide{картинка с оптимизаторами, которые чего-то спрашивают у анализаторов}
  Для ответа на этот и подобные вопросы существуют
  анализаторы, компоненты оптимизирующего компилятора, которые предоставляют
  информацию о каких-либо характеристиках программы.

  \paragraph{Что такое анализ синонимов и указателей.}
  \slide{анализ синонимов и... указателей (с английскими названиями)}
  В моей работе рассматривается анализ синонимов, который предоставляет
  информацию о том, могут ли два выражения ссылочного типа быть синонимами, то
  есть ссылаться на один и тот же объект. Однако анализ синонимов тесно связан
  с анализом указателей, который предоставляет более общую информацию:
  множество всех объектов, на которые может ссылаться выражение.

  \paragraph{О многопоточных программах.}
  \slide{проблемы неопределенности множества целей полей объектов..}
  Необходимо так же упомянуть о многопоточных программах. Вообще,
  существование многопоточных программ и многопроцессорных систем усложняет
  проведение анализа: при анализе отдельного метода программы нужно помнить,
  что поля объектов могут изменяться не только в этом методе, но и в методах
  других потоков.
  \slide{... запись в поле может быть не видна другим потока}
  Ситуация становится еще более запутанной на современных процессорах, которые
  имеют многоуровневые кэши для каждого ядра процессора: запись в поле объекта
  одним потоком может быть не видна другим.
  В простейшем случае для таких систем анализ указателей для полей объектов
  вообще не будет давать хоть сколько-нибудь полезной информации.

  \paragraph{Постановка задачи.}
  \slide{цель и... задачи}
  Теперь я хотел бы вернуться к цели, которая была поставлена передо мной в
  этой работе: разработка внутрипроцедурного алгоритма указателей и внутренного
  представления для использования в оптимизирующем статическом компиляторе Java
  программ. Для достижения этой цели необходимо были изучить существующие
  алгоритмы анализа указателей, выбрать наиболее подходящий для данной работы,
  адаптировать его для анализа многопоточных Java программ и реализовать в
  оптимизирующем статическом Java компиляторе \eng{Excelsior Research Virtual
  Machine}.

  \paragraph{О существующих алгоритмах.}
  \slide{алгоритмы Андерсена, Стинс\-гар\-да, их оценки по сложности}
  На данный момент существует несколько классических алгоритмов анализа
  указателей разработанных для языка C и их многочисленные модификации, которые
  отличаются по скорости работы и точности получаемых результатов. Мною был
  выбран алгоритм Андерсена, предоставляющий более точные результаты. В общем
  случае он является более медленным нежели практически линейный по времени
  алгоритм Стинсгарда, но это не так критично при внутрипроцедурном анализе,
  так как размер анализируемого участка зачастую небольшой.

  \paragraph{Улучшения: информация о типах и JMM.}
  \slide{C $\neq$ Java: адресная арифметика, указатели на фукнции, указатели на
  другие указатели, строгая типизация и ...}
  Однако недостаточно просто взять алгоритм Андерсена, который изначально
  разрабатывался для языка C, он будет работать совершенно не эффективно.
  Необходимо адаптировать его для анализа языка Java! Язык Java является языком
  со строгой типизацией: выражения могут указывать только на объекты,
  совместимые по присваиванию с формальным типом этого выражения, и так же
  необходимо заметить, что эти объекты могут лежать только в куче.
  Соответственно, оригинальный алгоритм был адаптирован для моей задачи на
  основании этих отличий Java от C.

  Но это не все особенности языка Java.
  \slide{Чтение обычного и \eng{volatile} поля}
  В 2005 году появилась модель памяти языка, которая предоставляет строгое
  описание как именно могут взаимодействовать потоки через разделяемую память.
  В частности модель памяти обязывает перечитывать значения всех полей после
  чтения какого-либо \eng{volatile} поля, однако позволяет потокам сохранить
  локальные копии обычных полей после чтения обычного поле: в данном примере
  здесь мы можем заменить операцию чтения, а здесь нет. Так же значения
  \eng{final} полей можно хранить в виде локальных копий независимо от других
  операций. Этот и другие факты позволяют определять, что именно может быть
  прочитано из полей объекта, и эта информация является безусловно полезной для
  моей работы.

  \paragraph{Практические результаты.}
  \slide{сравнение разных версий алгоритма: простой и адаптированные мною}
  Разработанный алгоритм был реализован в рамках оптимизирующего Java
  компилятора и будет протестирован на наборе прилоежений с целью измерения его
  скорости и точности, и сравнения этих характеристик с алгоритмами не
  адаптированными для анализа многопоточных Java программ.

  \paragraph{Заключение.}
  \slide{выполненные задачи}
  Переходя к заключению, я хотел бы напомнить, что передо мной была поставлена
  цель разработки внутрипроцедурного алгоритма анализа указателей для
  многопоточных программ и эта цель была успешно достигнута.
  В ходе работы был
  проведен анализ существующих алгоритмов анализа указателей и реализован
  тестовый стенд позволяющий сравнивать их характеристики;
  изучена спецификация модели памяти языка Java;
  разработан алгоритм анализа и оптимальное внутреннее представление,
  учитывающие особенности языка Java и его модели памяти;
  и в рамках статического оптимизирующего Java компилятор Excelsior RVM
  был реализован представленный алгоритм.

  В дальнейшем планируется реализация данного алгоритма в промышленном
  компиляторе Excelsior JET, и расширение алгоритма для проведения
  межпроцедурного анализа.

  \slide{спасибо, вопросы?}
  Спасибо за внимание, я готов ответить на ваши вопросы.

\end{document}

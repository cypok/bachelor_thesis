\documentclass[12pt]{article}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[usenames,dvipsnames]{color}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[pdftex]{graphicx}
\usepackage{multicol}

\usepackage[left=2.5cm,right=2.5cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\linespread{1.3}

\title{
  «Анализ указателей и синонимов для многопоточных программ»\\
  Презентация
}
\author{
  Владимир Парфиненко
}

%\newcommand{\remark}[1]{}
\newcommand{\remark}[1]{\textcolor{Green}{#1}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\todocite}{[\todo{cite}]}

\newcommand{\slide}[1]{\textcolor{Blue}{[Слайд: #1]}}

\newcommand{\eng}[1]{{\English#1}}

\begin{document}
  {\Large Текст презентации к защите, 10 минут}
  \vspace{5mm}

  \paragraph{Кто я.}
  \slide{титульный с названием и фамилиями моей и научрука}
  Здравствуйте, меня зовут Владимир Парфиненко, я являюсь студентом 4-го
  курса Новосибирского Государственного Университета, и тема моей работы
  <<Анализ указателей и синонимов для многопоточных программ>>.

  \paragraph{Место анализа.}
  Я начну с краткого введения в предметную область моей работы: статический
  анализ.
  \slide{многообразие статических анализаторов и оптимизирующих компиляторов}
  Этот вид анализа применяется в оптимизирующих компиляторах и в инструментах
  статического анализа кода.  Остановимся подробнее на оптимизирующих
  компиляторах.
  Оптимизация программы~--- это ее преобразование с целью улучшения какой-либо
  характеристики (скорость исполнения, потребление памяти и так далее).
  Рассмотрим простой пример оптимизации:
  \slide{тривиальный вынос инварианта из цикла...}
  В данном примере видно, что выражение $t = y.f$ можно вынести из цикла,
  что ускорит исполнение программы. Но нужно помнить, что это преобразование
  должно быть корректным: оно должно сохранять семантику программу.
  \slide{... может быть неудачным если переменные синонимы}
  Однако подобный вынос может изменить семантику программы: если переменные $x$
  и $y$ будут ссылаться на один объект, то значение $y.f$ будет разным на
  каждой итерации цикла. Значит, если мы хотим провести эту оптимизацию
  необходимо нечто, что сможет ответить на вопрос, могут ли две переменные
  ссылаться на один объект.
  \slide{картинка с оптимизаторами, которые чего-то спрашивают у анализаторов}
  Для ответа на этот и подобные вопросы существуют
  анализаторы, компоненты оптимизирующего компилятора, которые предоставляют
  информацию о каких-либо характеристиках программы.

  \paragraph{Что такое анализ синонимов и указателей.}
  \slide{анализ синонимов и... указателей (с английскими названиями)}
  В моей работе рассматривается анализ синонимов, который предоставляет
  информацию о том, могут ли два выражения ссылочного типа быть синонимами, то
  есть ссылаться на один и тот же объект. Однако анализ синонимов тесно связан
  с анализом указателей, который предоставляет более общую информацию:
  множество всех объектов, на которые может ссылаться выражение.

  \paragraph{О многопоточных программах.}
  \slide{проблемы неопределенности множества целей полей объектов..}
  Необходимо так же упомянуть о многопоточных программах. Вообще,
  существование многопоточных программ и многопроцессорных систем усложняет
  проведение анализа: при анализе отдельного метода программы нужно помнить,
  что поля объектов могут изменяться не только в этом методе, но и в методах
  других потоков.
  \slide{... поле может измениться другим потоками}
  Ситуация становится еще более запутанной на современных процессорах, которые
  имеют многоуровневые кэши для каждого ядра процессора: запись в поле объекта
  одним потоком может быть не видна другим.
  \slide{... запись в поле может быть не видна другим потока}
  В простейшем случае для таких систем анализ указателей для полей объектов
  вообще не будет давать хоть сколько-нибудь полезной информации.

  \paragraph{Постановка задачи.}
  \slide{цель и... задачи}
  Теперь я хотел бы вернуться к цели, которая была поставлена передо мной в
  этой работе: разработка внутрипроцедурного алгоритма указателей и внутренного
  представления для использования в оптимизирующем статическом компиляторе Java
  программ. Для достижения этой цели необходимо было изучить существующие
  алгоритмы анализа указателей, выбрать наиболее подходящий для данной работы,
  адаптировать его для анализа многопоточных Java программ и реализовать в
  оптимизирующем статическом Java компиляторе \eng{Excelsior Research Virtual
  Machine}.

  \paragraph{О существующих алгоритмах.}
  \slide{алгоритмы Андерсена, Стинс\-гар\-да, их оценки по сложности}
  На данный момент существует несколько классических алгоритмов анализа
  указателей разработанных для языка C и их многочисленные модификации, которые
  отличаются по скорости работы и точности получаемых результатов. Мною был
  выбран алгоритм Андерсена, предоставляющий более точные результаты. В общем
  случае он является более медленным нежели практически линейный по времени
  алгоритм Стинсгарда, но это не так критично при внутрипроцедурном анализе,
  так как размер анализируемого участка зачастую небольшой.

  \paragraph{Идея алгоритма}
  Подробное описание алгоритма выходит за рамки данной презентации, но я хотел
  бы представить основную его идею.
  \slide{выражения и присваивание}
  Она заключается в последовательной интерпретации присваиваний выражений
  ссылочного типа, с точки зрений множества целей этих выражений. Допустим в
  программе присутствует присваивание вида $lhs = rhs$, где изначально
  $lhs$ могло указывать на объекты $O_1, O_2$, а $rhs$ на $O_2, O_3$. Такое
  присваивание следует трактовать как расширение множества целей выражения
  слева множеством целей выражения справа, то есть в данном случае получаем,
  что после этого присваивания выражение $lhs$ может указывать на $O_1, O_2,
  O_3$. Этот процесс следует продолжать для всех присваиваний до тех пор, пока
  множества целей всех выражений не стабилизируются.

  \paragraph{Улучшения: информация о типах и JMM.}
  \slide{C $\neq$ Java: адресная арифметика, указатели на фукнции, указатели на
  другие указатели, строгая типизация и ...}
  Однако недостаточно просто взять алгоритм Андерсена, который изначально
  разрабатывался для языка C, он будет работать совершенно не эффективно.
  Необходимо адаптировать его для анализа языка Java! Язык Java является языком
  со строгой типизацией: выражения могут указывать только на объекты,
  совместимые по присваиванию с формальным типом этого выражения, и так же
  необходимо заметить, что эти объекты могут лежать только в куче.
  Соответственно, оригинальный алгоритм был адаптирован для моей задачи на
  основании этих отличий Java от C.

  Но это не все особенности языка Java.
  \slide{Чтение обычного и \eng{volatile} поля}
  В 2005 году появилась модель памяти языка, которая предоставляет строгое
  описание как именно могут взаимодействовать потоки через разделяемую память.
  В частности модель памяти обязывает перечитывать значения всех полей после
  чтения какого-либо \eng{volatile} поля, однако позволяет потокам сохранить
  локальные копии обычных полей после чтения обычного поле: в данном примере
  здесь мы можем заменить операцию чтения, а здесь нет.
  Этот и другие факты позволяют определять, что именно может быть
  прочитано из полей объекта, и эта информация является безусловно полезной для
  моей работы.

  \paragraph{Внутреннее представление.}
  \slide{Кусок Java программы}
  Известно, что сложность алгоритма отчасти определяется используемыми
  структурами данных. Поэтому в данной работе также было уделено внимание
  разработке подходящего внутреннего представления программы, с которым будет
  работать алгоритм анализа.
  \slide{... интересная нам часть куска Java программы}
  В частности, разработанное представление содержит только ту информацию,
  которая необходима и достаточна для проведения анализа, что позволяет
  упростить логику алгоритма и его реализацию.
  \slide{... ОО представление}
  Также, применение объектно-ориентированного подхода, позволяет еще сильнее
  упростить основную часть алгоритма за счет группировки данных и методов их
  обработки и обеспечить удобный доступ клиентов анализа к его результатам.

  \paragraph{Практические результаты.}
  \slide{алгоритм реализован и протестирован на приложениях: ...}
  Разработанный алгоритм был реализован в рамках оптимизирующего Java
  компилятора. Была проведена серия экспериментов, в ходе которых удалось
  измерить различные характеристики алгоритма.
  \slide{временная сложность}
  Видно, что на практике алгоритм работает за время, пропорциональное
  квадрату размера метода, что согласуется с теоретически расчитанной
  временной сложностью алгоритма, которая есть $O(N^3)$ в худшем случае,
  причем видно, что на практике <<худший случай>> не достигается.
  \slide{емкостная сложность}
  Объем памяти, потребляемый алгоритмом, имеет существенный разброс при анализе
  больших методов, но может быть оценен сверху величиной, пропорциональной
  квадрату размера метода. Такой результат, в частности, является приемлимым
  для использования в рамках оптимизирующего компилятора.
  \slide{что будем сравнивать}
  Также было произведено сравнение точности разработанного алгоритма со
  следующими его вариациями: алгоритмом не учитывающим строгую типизацию языка,
  алгоритмом не учитывающим потоки данных и алгоритмом, основанном на алгоритме
  Стинсгарда.
  \slide{сравнение точности}
  На графике распределения точности чем выше проходит кривая, тем
  более точными являются результаты анализа. И видно, что разработанный
  алгоритм, красная кривая, дает существенно более точные результаты чем
  его вариации, не учитывающие каких-либо особенностей языка, что
  оправдывает выбор алгоритма, сделанный в работе, и примененные к нему
  адаптации.
  \slide{сравнение точности на примере Eclipse IDE}
  Причем разные адаптации могут вносить существенно разный вклад в зависимости
  от анализируемой программы, здесь можно видеть что без учета потока данных
  точность упала сильнее чем в случае предыдущей программы.

  \paragraph{Заключение.}
  \slide{выполненные задачи}
  Переходя к заключению, я хотел бы напомнить, что передо мной была поставлена
  цель разработки внутрипроцедурного алгоритма анализа указателей для
  многопоточных программ и эта цель была успешно достигнута.
  В ходе работы был проведен анализ существующих алгоритмов анализа указателей
  и реализован тестовый стенд позволяющий сравнивать их характеристики.
  Изучена спецификация языка Java и его модели памяти, что позволило
  разработать алгоритм анализа и оптимальное внутреннее представление,
  учитывающие особенности многопоточных Java-программ. В рамках статического
  оптимизирующего Java компилятор Excelsior RVM был реализован представленный
  алгоритм, и были проведены практические замеры его временной и емкостной
  сложности, а также сравнение с другими алгоритмами анализа.

  В дальнейшем планируется реализация данного алгоритма в промышленном
  компиляторе Excelsior JET, и расширение алгоритма для проведения
  межпроцедурного анализа.

  \slide{спасибо, вопросы?}
  Спасибо за внимание, я готов ответить на ваши вопросы.

\end{document}

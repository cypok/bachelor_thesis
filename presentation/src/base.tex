\documentclass[12pt]{article}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[usenames,dvipsnames]{color}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[pdftex]{graphicx}
\usepackage{multicol}


\title{
  «Анализ указателей и синонимов для многопоточных программ»\\
  Презентация
}
\author{
  Владимир Парфиненко
}

%\newcommand{\remark}[1]{}
\newcommand{\remark}[1]{\textcolor{Green}{#1}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\todocite}{[\todo{cite}]}

\newcommand{\slide}[1]{\textcolor{Blue}{[Слайд: #1]}}

\newcommand{\eng}[1]{{\English#1}}

\begin{document}
  {\Large Текст презентации к предзащите, 5 минут}
  \vspace{5mm}

  \paragraph{Кто я.}
  \slide{титульный с названием и фамилиями моей и научрука}
  Здравствуйте, меня зовут Владимир Парфиненко, являюсь студентом 4-го
  курса Новосибирского Государственного Университета, и тема моей работы
  <<Анализ указателей и синонимов для многопоточных программ>>.

  \todo{\paragraph{Содержание.} На защите огласить план всей презентации}

  \paragraph{Место анализа.}
  Я начну с короткого введения в предметную область моей работы: статический
  анализ.
  \slide{многообразие статических анализаторов и оптимизирующих компиляторов}
  Этот вид анализа применяется в оптимизирующих компиляторах и в инструментах
  статического анализа кода.  Остановимся подробнее на оптимизирующих
  компиляторах.
  Оптимизация программы~--- это ее преобразование с целью улучшения какой-либо
  характеристики (скорость исполнения, потребление памяти). Рассмотрим простой
  пример оптимизации: \slide{тривиальный вынос инварианта из цикла}
  В данном примере видно, что выражение $a[i] = y.g$ можно вынести из цикла,
  что ускорит исполнение программы. Но нужно помнить, что это преобразование
  должно быть корректным: оно должно сохранять семантику программу.
  \slide{неудачный вынос если переменные синонимы}
  Если вместо поля $g$ будет читаться поле $f$, то подобный вынос может
  изменить семантику программы: если переменные $x$ и $y$ будут ссылаться на
  один объект, то значение $y.f$ будет разным на каждой итерации цикла.
  Значит, если мы хотим провести эту оптимизацию необходимо нечто, что
  сможет ответить на вопрос, могут ли две переменные ссылаться на один объект.
  \slide{картика с оптимизаторами, которые чего-то спрашивают у анализаторов}
  Для ответа на этот и подобные вопросы существуют
  анализаторы, компоненты оптимизирующего компилятора, которые предоставляют
  информацию о каких-либо характеристиках программы.

  \paragraph{Что такое анализ синонимов и указателей.}
  \slide{анализ синонимов и... указателей (с английскими названиями)}
  В моей работе рассматривается анализ синонимов, который предоставляет
  информацию о том, могут ли два выражения ссылочного типа быть синонимами, то
  есть ссылаться на один и тот же объект. Однако анализ синонимов тесно связан
  с анализом указателей, который предоставляет более общую информацию:
  множество всех объектов, на которые может ссылаться выражение.

  \paragraph{О многопоточных программах.}
  \slide{пример с проблемами неопределенности множества целей полей объектов}
  Необходимо так же упомянуть о многопоточных программах. Вообще,
  существование многопоточных программ и многопроцессорных систем усложняет
  проведение анализа: при анализе отдельного метода программы нужно помнить,
  что поля объектов могут изменяться не только в этом методе, но и в методах
  других потоков. В простейшем случае анализ указателей для полей объектов
  вообще не будет давать хоть сколько-нибудь полезной информации.

  \paragraph{Постановка задачи.}
  \slide{цель и... задачи}
  Теперь я хотел бы вернуться к цели, которая была поставлена передо мной в
  этой работе: разработка внутрипроцедурного алгоритма указателей и внутренного
  представления для использования в оптимизирующем статическом компиляторе Java
  программ. Для достижения этой цели необходимо были изучить существующие
  алгоритмы анализа указателей, выбрать наиболее подходящий для данной работы,
  адаптировать его для анализа многопоточных Java программ и реализовать в
  оптимизирующем статическом Java компиляторе \eng{Excelsior Research Virtual
  Machine}.

  \paragraph{О существующих алгоритмах.}
  \slide{алгоритмы Андерсена, Стинс\-гар\-да, их оценки по сложности}
  На данный момент существует несколько классических алгоритмов анализа
  указателей разработанных для языка C и их многочисленные модификации, которые
  отличаются по скорости работы и точности получаемых результатов. Мною был
  выбран алгоритм Андерсена, предоставляющий более точные результаты. В общем
  случае он является более медленным, но это не так критично при
  внутрипроцедурном анализе, так как размер анализируемого участка зачастую
  небольшой.

  \paragraph{Улучшения: информация о типах и JMM.}
  \slide{C $\neq$ Java: адресная арифметика, указатели на фукнции, указатели на
  другие указатели, строгая типизация и ...}
  Однако недостаточно просто взять алгоритм Андерсена, который изначально
  разрабатывался для языка C. Необходимо адаптировать его для анализа языка
  Java! В нем выражения могут указывать только на объекты в куче, и плюс язык
  Java является языком со строгой типизацией: выражения могут указывать только
  на объекты, совместимые по присваиванию с формальным типом этого выражения.

  \paragraph{Практические результаты.}

  \paragraph{Заключение.}
  ...
  \slide{спасибо, вопросы?}
  Спасибо за внимание, я готов ответить на ваши вопросы.

\end{document}

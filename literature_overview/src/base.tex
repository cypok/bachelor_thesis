\documentclass[12pt]{article}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{color}

%\textwidth=16cm
%\oddsidemargin=0pt
\topmargin=0pt
\headheight=0pt
\headsep=0pt
\textheight=22cm
\linespread{1.3}

%\newcommand{\remark}[1]{}
\newcommand{\remark}[1]{\textcolor{blue}{#1}}

\newcommand{\eng}[1]{{\English#1}}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\title{
  Обзор литературы на тему \\
  «Анализ указателей и синонимов\\ для многопоточных программ»
}
\author{
  Владимир Парфиненко
}

\begin{document}
  \maketitle

    \paragraph{Lars Ole Andersen.}
      \eng{
        \textit{Program Analysis and Specialization for
          the C Programming Language.}
        PhD thesis, Department of Computer Science, University of Copenhagen,
        May 1994.
      }

      Довольно большая работа, из которой я изучил Главу 4 «Pointer Analysis»
      (с.~111--152). В ней описываются основные характеристики, которыми
      может обладать алгоритм анализа, влияющие на его скорость и точность.

      Суммарный (\eng{summary, flow-insensitive}) анализ предоставляет
      результат верный для любой точки программы, в то время как точечный
      (\eng{prog\-ram-point specific, flow-sensitive}) вычисляет результат
      для каждой отдельной точки программы, что значительно повышает точность
      анализа, но понижает производительность.

      Также в работе показывается, что меж-процедурные алгоритмы повышают
      точность анализа, но сами по себе сложнее и требуют больше ресурсов по
      сравнению с внутри-процедурными алгоритмами.

      Затем автор переходит к описанию своего меж-процедурного
      алгоритма анализа, вводя понятие абстракного места и
      абстрактного указателя~--- отношение из абстрактных мест в множество
      абстракных мест. В этих терминах он формулирует алгоритм анализа, который
      состоит в построении системы ограничений и дальнейшем ее решении.


    \paragraph{Bjarne Steensgaard.}
      \eng{
        \textit{Points-to analysis in almost linear time.}
        Microsoft Research,
        March 1995.
      }

      Автор описывает другой алгоритм, характерной чертой которого является
      практически линейное время работы. Также формулируется система типов
      и ограничений на нее, с описанием алгоритма решения.

      Особенность алгоритма заключается в том, что присваивание $x = y$
      накладывает ограничение на полное равенство типов,
      $\tau_x = \tau_y$ (\eng{equality-based}),
      в то время как алгоритм представленный в работе Андерсена требует лишь,
      чтобы один из типов был подмножеством другого,
      $\tau_x \supset \tau_y$ (\eng{subset-based}).
      За счет такого ограничения алгоритм становится менее точным, но более
      быстрым с точки зрения производительности.

    \paragraph{Derek Rayside.}
      \eng{
        \textit{Points-To Analysis.}
        MIT CSAIL 6.883, Prof Ernst,
        November 14, 2005.
      }

      Очень небольшая статья, в которой автор разделяет разные алгоритмы
      анализа на группы, и на примерах показывает сильные и слабые стороны
      \eng{equality-based} и \eng{subset-based} алгоритмов.

    \paragraph{Marc Shapiro, Susan Horwitz.}
      \eng{
        \textit{Fast and Accurate Flow-Insensitive Points-To Analysis.}
        Computer Sciences Department, University of Wisconsin-Madison,
        1997.
      }

      В этой работе сначала приводятся экспериментальные данные о
      производительности и точности алгоритмов Стинсгарда и Андерсена.
      Показывается что на небольших программах (менее 3000 строк) время работы
      примерно одинаково, но точность у алгоритма Андерсена значительно выше,
      на больших программах же время работы алгоритма Андерсена растет гораздо
      быстрее.

      Так же в работе представлены два новых алгоритма.  Первый является
      расширением алгоритма Стинсгарда, в котором вводятся категории
      переменных, фактически, это компромисс между
      точностью алгоритма Андерсена и скоростью алгоритма Стинсгарда.
      За счет изменения количества этих категорий и разбиения переменных
      на них алгоритм может либо давать более точные результаты, либо быстрее
      работать.

      Второй алгоритм использует первый. Суть алгоритма заключается в
      фиксировании количества категорий и использованию первого алгоритма
      несколько раз с разным разбиением объектов на категории. За счет этого
      можно значительно повысить точность и не так сильно понизить
      производительность.

    \paragraph{John Whaley, Martin Rinard.}
      \eng{
        \textit{Compositional Pointer and Escape Analysis for Java Programs.}
        Laboratory for Computer Science, MIT,
        1999.
      }

      В этой работе описывается алгоритм совмещенного анализа указателей и
      escape-анализа для Java программ. Для каждого анализируемого
      метода строится специальный граф, в котором содержится информация о том,
      на какие объекты могут указывать переменные и поля других объектов.

      Автор указывает, как должен изменяться граф при анализе различных
      конструкций языка (присваивание, присваивание в поле и др.).
      Задав граф перед началом анализа метода, мы можем последовательно
      проанализировать весь метод и либо узнать информацию об указателях в
      любой точке метода, если это необходимо, либо в конце получить суммарную
      информацию для метода. Из графа также можно получить информацию о том,
      какие объекты могут быть доступны вне анализируемого метода, а какие нет
      (escape-анализ).

      Алгоритм предусматривает и межпроцедурный анализ. Если при анализе
      метода встречается вызов другого метода, то мы можем либо пропустить его
      и изменить граф согласно консервативному предположению (все объекты
      переданные как параметры «утекают»), либо, если нам доступен суммарный
      результат анализа всех методов, которые могут быть вызваны, можно внести
      эти результаты в граф текущего метода. Данная процедура также подробно
      описана автором.

      В конце автор приводит примеры, как этот алгоритм анализа может быть
      использован для удаления синхронизации по объектам, локальным для одного
      потока (\eng{synchronization-elimination}), и
      для выделения памяти на стеке под объекты доступные только внутри метода
      (\eng{stack-allocation}).

    \paragraph{Amer Diwan, Kathryn S.~McKinley, J.~Eliot B.~Moss.}
      \eng{
        \textit{Type-Based Alias Analysis.}
        In the 1998 Proc. ACM SIGPLAN Conference on Programming Language
        Design and Implementation (PLDI’98).
      }

      В этой работе представлено три алгоритма анализа синонимов для языков со
      строгой типизацией, в качестве примера используется Модула-3.
      Первый алгоритм для определения того факта, что два указателя указывают
      на один объект, использует совместимость типов указателей по
      присваиванию. \remark{Подробнее можно раскрыть в тексте основной
      работы.} Второй алгоритм расширяет первый используя дополнительную
      информацию о указателях. Третий алгоритм добавляет во второй
      потоко-независимый анализ подобный анализу указателей Стинсгарда.

    \paragraph{Michael Hind.}
      \eng{
        \textit{Pointer Analysis: Haven't We Solved This Problem Yet?}
        IBM Watson Research Center, Hawthorne, New Yourk 10532.
      }

      В этой статье описываются открытые проблемы в области анализа указателей,
      которые пока не позволяют использовать одновременно точный и эффективный
      алгоритм в промышленных анализаторах.
      Затрагиваются следующие общие проблемы, относящиеся ко всем работам
      посвященным анализу указателей:
      \begin{itemize}
        \item разнообразие терминов, использующихся
          для именования одних и тех же техник и свойств алгоритмов;
        \item не ясно, как измерять точность анализа
          указателей, автор описывает три варианта, каждый из которых имеет
          недостатки;
        \item проблема воспроизводимости результатов, которые показал алгоритм,
          из-за чего сложно сравнивать эффективность алгоритмов, предложенных
          разными исследователями.
      \end{itemize}

      Так же автор останавливается на следующих вопросах, не выдвигая
      каких-либо новых предложений:
      \begin{itemize}
        \item масштабируемость;
        \item повышение точности;
        \item потоко-/контексто-зависимость;
        \item анализ составных объектов;
        \item анализ программ на языке Java и других ОО ЯП.
      \end{itemize}


\end{document}

